{"version":3,"file":"test-base.js","sourceRoot":"","sources":["../../src/test-base.ts"],"names":[],"mappings":"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","sourcesContent":["import * as stack from '@tapjs/stack'\r\nimport type { Test } from '@tapjs/test'\r\nimport { isPromise } from 'is-actual-promise'\r\nimport { Minipass } from 'minipass'\r\nimport assert from 'node:assert'\r\nimport { relative } from 'node:path'\r\nimport { hrtime } from 'node:process'\r\nimport { Readable } from 'node:stream'\r\nimport { format } from 'node:util'\r\nimport { FinalResults, Result as ParserResult } from 'tap-parser'\r\nimport { Deferred } from 'trivial-deferred'\r\nimport { Base, BaseOpts } from './base.js'\r\nimport { esc } from './esc.js'\r\nimport { extraFromError } from './extra-from-error.js'\r\nimport { mainScript } from './main-script.js'\r\nimport { argv, cwd } from './proc.js'\r\nimport { Spawn } from './spawn.js'\r\nimport { Stdin } from './stdin.js'\r\nimport { Result, TestPoint } from './test-point.js'\r\nimport { Waiter } from './waiter.js'\r\nimport { Worker } from './worker.js'\r\n\r\nimport { IMPLICIT } from './implicit-end-sigil.js'\r\nimport {\r\n  Extra,\r\n  MessageExtra,\r\n  TapBaseEvents,\r\n  TapFile,\r\n} from './index.js'\r\nimport { normalizeMessageExtra } from './normalize-message-extra.js'\r\n\r\nconst VERSION = 'TAP version 14\\n'\r\n\r\n/**\r\n * Options that can be passed to TestBase objects\r\n */\r\nexport interface TestBaseOpts extends BaseOpts {\r\n  /**\r\n   * The number of jobs to run in parallel. Defaults to 1\r\n   */\r\n  jobs?: number\r\n\r\n  /**\r\n   * Test function called when this Test is executed\r\n   * This is usually not set on the extra object, but as an argument to\r\n   * the `t.test(..)` method, just defined here so TS doesn't complain\r\n   * when we reference it in the various flow control machinery.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  cb?: (...args: any[]) => any\r\n}\r\n\r\nconst queueEmpty = <T extends TestBase>(t: T) =>\r\n  t.queue.length === 0 ||\r\n  (t.queue.length === 1 && t.queue[0] === VERSION)\r\n\r\n/**\r\n * Sigil to put in the queue to signal the end of all things\r\n */\r\nconst EOF = Symbol('EOF')\r\n\r\nexport type { EOF }\r\n\r\n/**\r\n * Entries in the {@link @tapjs/core!test-base.TestBase#queue} awaiting\r\n * processing\r\n */\r\nexport type QueueEntry =\r\n  | string\r\n  | TestPoint\r\n  | Base\r\n  | typeof EOF\r\n  | Waiter\r\n  | [method: string, ...args: any[]]\r\n  | (() => any)\r\n\r\n/**\r\n * the promise returned by t.test(), t.spawn(), etc.\r\n * If a subtest was not created (because of being marked skipped,\r\n * the parent having bailed out, etc.) then the `subtest` field\r\n * will be set to `null`.\r\n */\r\nexport interface PromiseWithSubtest<S extends Base>\r\n  extends Promise<FinalResults | null> {\r\n  subtest: S | null\r\n}\r\n\r\n/**\r\n * Events emitted by TestBase and inherited classes\r\n */\r\nexport interface TestBaseEvents extends TapBaseEvents {\r\n  /**\r\n   * Emitted when a subtest begins running\r\n   *\r\n   * @event\r\n   */\r\n  subtestStart: [p: Base]\r\n  /**\r\n   * Emitted when a subtest is completed and no longer active, but may\r\n   * not yet have been processed by the parent test.\r\n   *\r\n   * @event\r\n   */\r\n  subtestEnd: [p: Base]\r\n  /**\r\n   * Emitted when a subtest begins to be processed.\r\n   *\r\n   * @event\r\n   */\r\n  subtestProcess: [p: Base]\r\n  /**\r\n   * Emitted when a subtest is added to its parent's management\r\n   *\r\n   * @event\r\n   */\r\n  subtestAdd: [p: Base]\r\n  /**\r\n   * Emitted whenever the test has an assertion result, with the minimal\r\n   * `{ ok, message, extra }` result object.\r\n   *\r\n   * @event\r\n   */\r\n  result: [res: Result]\r\n  /**\r\n   * Emitted when the parser emits a result, with the full parser result\r\n   * object\r\n   *\r\n   * @event\r\n   */\r\n  assert: [res: ParserResult]\r\n  /**\r\n   * Emitted when a child test is initiated that will process stdin\r\n   * as a TAP stream\r\n   *\r\n   * @event\r\n   */\r\n  stdin: [s: Stdin]\r\n  /**\r\n   * Emitted when a child test is initiated that will process a subprocess\r\n   * output as a TAP stream\r\n   *\r\n   * @event\r\n   */\r\n  spawn: [s: Spawn]\r\n  /**\r\n   * Emitted when a child test is initiated that will process a node\r\n   * Worker thread's output as a TAP stream\r\n   *\r\n   * @event\r\n   */\r\n  worker: [w: Worker]\r\n  /**\r\n   * Emitted when a child tests is initiated that replays a .tap file.\r\n   *\r\n   * @event\r\n   */\r\n  tapFile: [tf: TapFile]\r\n  /**\r\n   * Emitted when the test is in an idle state, not waiting\r\n   * for anything, with nothing in its queue. Used by the root\r\n   * {@link @tapjs/core!tap.TAP} singleton to know when to automatically\r\n   * terminate.\r\n   *\r\n   * @event\r\n   */\r\n  idle: []\r\n}\r\n\r\n/**\r\n * The TestBase class is the parent class of {@link @tapjs/test!index.Test},\r\n * and passed\r\n * to all plugins at instantiation time.\r\n *\r\n * This implements subtest functionality, TAP stream generation,\r\n * lifecycle events, and only the basic pass/fail assertion methods.\r\n *\r\n * All other features are added with plugins.\r\n */\r\nexport class TestBase extends Base<TestBaseEvents> {\r\n  // NB: generated pluginified Test class needs to declare over this\r\n  declare parent?: TestBase\r\n  declare options: TestBaseOpts\r\n\r\n  /**\r\n   * Attached when the Test class is instantiated from a TestBase,\r\n   * as a reference to the final plugged-in Test instance.\r\n   * If TestBase is used directly (outside the context of a plugin)\r\n   * or during plugin setup time, this will be undefined, so watch out.\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  t!: Test\r\n\r\n  /**\r\n   * A promise that resolves when the test is done.\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  donePromise?: Promise<any> & {\r\n    tapAbortPromise?: () => void\r\n  }\r\n\r\n  /**\r\n   * The number of subtests to run in parallel, if allowed\r\n   *\r\n   * @group Test Lifecycle Management\r\n   */\r\n  jobs: number\r\n\r\n  /**\r\n   * Array of all subtests that have been added/scheduled,\r\n   * and have not yet completed.\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  subtests: Base[] = []\r\n  /**\r\n   * The pool of parallel tests currently in process\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  pool: Set<Base> = new Set()\r\n  /**\r\n   * Queue of items awaiting processing. Can be any\r\n   * {@link @tapjs/core!test-base.QueueEntry} item.\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  queue: QueueEntry[] = [VERSION]\r\n  /**\r\n   * Function that will get this test as an argument when it is processed\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  cb?: (...args: any[]) => any\r\n\r\n  /**\r\n   * The count of all assertions made directly on this test.\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  count: number = 0\r\n\r\n  /**\r\n   * Set true when {@link @tapjs/core!test-base.TestBase#end} is called\r\n   */\r\n  ended: boolean = false\r\n\r\n  /**\r\n   * Show diagnostics for this test. A value of `null` means that\r\n   * diagnostics will be shown only if the test is failing.\r\n   */\r\n  diagnostic: null | boolean = null\r\n\r\n  #planEnd: number = -1\r\n  #planAt?: stack.CallSiteLike\r\n  #printedResult: boolean = false\r\n  #endingAll: boolean = false\r\n  #endingAllSub: boolean = false\r\n  #explicitEnded: boolean = false\r\n  #explicitPlan: boolean = false\r\n  #promiseEnded: boolean = false\r\n  #multiEndThrew: boolean = false\r\n  #n: number = 0\r\n  #noparallel: boolean = false\r\n  #occupied: null | Waiter | Base = null\r\n  // set to true if the end should be explicit\r\n  #awaitingEnd: typeof IMPLICIT | boolean = false\r\n  #pushedBeforeEnd: boolean = false\r\n  #nextChildId: number = 1\r\n  #currentAssert?: Function | ((..._: any) => any)\r\n  #processing: boolean = false\r\n  #doingStdinOnly: boolean = false\r\n  #calledOnEOF: boolean = false\r\n  #jobIds: Set<number>\r\n\r\n  /**\r\n   * Subtests that are currently in process.\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  activeSubtests: Set<Base> = new Set()\r\n\r\n  /**\r\n   * Count of all asserts in this and all child tests,\r\n   * excluding child test summary points\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  get assertTotals() {\r\n    return this.counts\r\n  }\r\n\r\n  /**\r\n   * true if the test has printed at least one TestPoint\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  get printedResult(): boolean {\r\n    return this.#printedResult\r\n  }\r\n\r\n  /**\r\n   * true if the test is currently waiting for something to finish\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  get occupied(): boolean {\r\n    return !!this.#occupied\r\n  }\r\n\r\n  constructor(options: TestBaseOpts) {\r\n    super(options)\r\n\r\n    this.parser.on('result', r => {\r\n      this.emit('assert', r)\r\n    })\r\n\r\n    this.jobs = (options.jobs && Math.max(options.jobs, 1)) || 1\r\n\r\n    if (typeof options.diagnostic === 'boolean') {\r\n      this.diagnostic = options.diagnostic\r\n    }\r\n\r\n    if (options.cb) {\r\n      this.#setCB(options.cb)\r\n    }\r\n    this.#jobIds = new Set()\r\n  }\r\n\r\n  #setCB<T extends TestBase>(this: T, cb: (t: T) => any) {\r\n    this.cb = (...args: any[]) =>\r\n      this.hook.runInAsyncScope(cb, this.t || this, ...args)\r\n  }\r\n\r\n  /**\r\n   * immediately exit this and all parent tests with a TAP\r\n   * Bail out! message.\r\n   *\r\n   * @group Test Lifecycle Management\r\n   */\r\n  bailout(message?: string) {\r\n    if (this.parent && (this.results || this.ended)) {\r\n      this.parent.bailout(message)\r\n    } else {\r\n      this.#process()\r\n      message = message ? ' ' + ('' + esc(message)).trim() : ''\r\n      message = message.replace(/[\\r\\n]/g, ' ')\r\n      this.parser.write('Bail out!' + message + '\\n')\r\n    }\r\n    this.#end(IMPLICIT)\r\n    this.#process()\r\n  }\r\n\r\n  /**\r\n   * output a TAP comment, formatted like console.log()\r\n   *\r\n   * If the test is currently awaiting a child test, it will be deferred\r\n   * until after the child test completes.\r\n   *\r\n   * If the test is already completed, the comment will be emitted\r\n   * on the parent, or if no parent is available, it will be printed\r\n   * to standard output.\r\n   */\r\n  comment(...args: any[]) {\r\n    const body = format(...args)\r\n    const message =\r\n      ('# ' + body.split(/\\r?\\n/).join('\\n# ')).trim() + '\\n'\r\n\r\n    if (this.results || this.ended || this.#awaitingEnd) {\r\n      // the fallback to console.log is a bit weird,\r\n      // but the only alternative seems to be to just lose it.\r\n      if (this.streamWritable) {\r\n        super.write(message)\r\n        this.parser.emit('comment', message.trim())\r\n      } else if (this.parent) {\r\n        this.parent.comment(...args)\r\n      } else {\r\n        console.log(message.trimEnd())\r\n      }\r\n    } else if (this.#occupied) {\r\n      this.queue.push(message)\r\n      this.#process()\r\n    } else {\r\n      this.parser.write(message)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the test times out.\r\n   * Options are passed as diagnostics to the threw() method\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  timeout(\r\n    options: Extra & { expired?: string } = { expired: this.name },\r\n  ) {\r\n    options.expired = options.expired || this.name\r\n    if (this.#occupied && this.#occupied instanceof Base) {\r\n      this.#occupied.timeout(options)\r\n    } else {\r\n      super.timeout(options)\r\n    }\r\n    this.#end(IMPLICIT)\r\n  }\r\n\r\n  /**\r\n   * Set TAP pragma configs to affect the behavior of the parser.\r\n   * Only `strict` is supported by the parser.\r\n   */\r\n  pragma(set: { [k: string]: boolean }) {\r\n    const p = Object.keys(set).reduce(\r\n      (acc, i) => acc + 'pragma ' + (set[i] ? '+' : '-') + i + '\\n',\r\n      '',\r\n    )\r\n    this.queue.push(p)\r\n    this.#process()\r\n  }\r\n\r\n  /**\r\n   * Specify the number of Test Points expected by this test.\r\n   * Outputs a TAP plan line.\r\n   *\r\n   * @group Test Lifecycle Management\r\n   */\r\n  plan(n: number, comment?: string): void\r\n  plan(n: number, comment: string, implicit: typeof IMPLICIT): void\r\n  plan(n: number, comment?: string, implicit?: typeof IMPLICIT) {\r\n    if (this.bailedOut) {\r\n      return\r\n    }\r\n\r\n    if (this.#explicitPlan) {\r\n      throw new Error('Cannot set plan more than once')\r\n    }\r\n    this.#explicitPlan = implicit !== IMPLICIT\r\n    if (this.#explicitPlan) {\r\n      this.#planAt = stack.at(this.plan)\r\n    }\r\n\r\n    if (this.#planEnd !== -1) {\r\n      throw new Error('Cannot set plan after test has ended')\r\n    }\r\n\r\n    if (typeof n !== 'number' || n < 0 || n !== Math.floor(n)) {\r\n      throw new TypeError('plan must be a non-negative integer')\r\n    }\r\n\r\n    // Cannot get any tests after a trailing plan, or a plan of 0\r\n    const ending = this.count !== 0 || n === 0\r\n\r\n    if (n === 0 && comment && !this.options.skip) {\r\n      this.options.skip = comment\r\n    }\r\n\r\n    this.#planEnd = n\r\n    comment = comment ? ' # ' + esc(comment.trim()) : ''\r\n    this.queue.push('1..' + n + comment + '\\n')\r\n\r\n    if (ending) {\r\n      this.#end(IMPLICIT)\r\n    } else {\r\n      this.#process()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A passing (ok) Test Point.\r\n   *\r\n   * @group Assertion Methods\r\n   */\r\n  pass(...[msg, extra]: MessageExtra) {\r\n    this.currentAssert = this.pass\r\n    const args = [msg, extra] as MessageExtra\r\n    const me = normalizeMessageExtra('(unnamed test)', args)\r\n    this.#printResult(true, ...me)\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * A failing (not ok) Test Point\r\n   *\r\n   * @group Assertion Methods\r\n   */\r\n  fail(...[msg, extra]: MessageExtra) {\r\n    this.currentAssert = this.fail\r\n    const args = [msg, extra] as MessageExtra\r\n    const me = normalizeMessageExtra('(unnamed test)', args)\r\n    this.#printResult(false, ...me)\r\n    return !!(me[1].todo || me[1].skip)\r\n  }\r\n\r\n  /**\r\n   * The current assertion being processed. Set at the start of all\r\n   * assertions, and used for calculating stack traces.\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  get currentAssert() {\r\n    return this.#currentAssert\r\n  }\r\n  set currentAssert(\r\n    fn: undefined | Function | ((...a: any[]) => any),\r\n  ) {\r\n    if (!this.#currentAssert && typeof fn === 'function') {\r\n      this.#currentAssert = fn\r\n    }\r\n  }\r\n\r\n  // apply flags from our options onto an Extra or TestOpts object\r\n  #inheritFlags(extra: Extra) {\r\n    const inheritedFlags = [\r\n      'bail',\r\n      'debug',\r\n      'passes',\r\n      'failTodo',\r\n      'failSkip',\r\n      'failOnly',\r\n      'diagnostic',\r\n    ] as const\r\n    for (const k of inheritedFlags) {\r\n      if (\r\n        extra[k] === undefined &&\r\n        typeof this.options[k] === 'boolean'\r\n      ) {\r\n        extra[k] = this.options[k]\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Print a Test Point.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  #printResult(\r\n    ok: boolean,\r\n    message: string,\r\n    extra: Extra,\r\n    front: boolean = false,\r\n  ) {\r\n    this.currentAssert = this.#printResult\r\n    this.#printedResult = true\r\n\r\n    const n = this.count + 1\r\n    const fn = this.currentAssert\r\n    this.#currentAssert = undefined\r\n\r\n    if (this.#planEnd !== -1 && n > this.#planEnd) {\r\n      // prevent infinite regress of \"plan exceeded\" fails\r\n      if (!this.passing()) return\r\n\r\n      // the 'automatic end' can only occur with the root TAP object\r\n      // and even then, pretty hard to trigger, since it would mean\r\n      // going several turns of the event loop and hitting it at just\r\n      // the right time before the process quits.\r\n      const failMessage =\r\n        this.#promiseEnded ? 'test assertion after Promise resolution'\r\n        : this.#explicitEnded ?\r\n          'test assertion after end() was called'\r\n        : this.#explicitPlan ? 'test assertion count exceeds plan'\r\n        : /* c8 ignore start */ 'assertion after automatic end'\r\n      /* c8 ignore stop */\r\n\r\n      const er = new Error(failMessage, {\r\n        cause: {\r\n          test: this.name,\r\n          plan: this.#planEnd,\r\n        },\r\n      })\r\n      Error.captureStackTrace(er, fn)\r\n      this.threw(er, extraFromError(er))\r\n      return\r\n    }\r\n\r\n    if (extra.skip && this.options.failSkip) {\r\n      extra.failedSkip = extra.skip\r\n      delete extra.skip\r\n      ok = false\r\n    }\r\n\r\n    if (extra.todo && this.options.failTodo) {\r\n      extra.failedTodo = extra.todo\r\n      delete extra.todo\r\n      ok = false\r\n    }\r\n\r\n    if (extra.only && this.options.failOnly) {\r\n      extra.failedOnly = 'only:true tests not allowed'\r\n      delete extra.only\r\n      ok = false\r\n    }\r\n\r\n    const diagnostic =\r\n      typeof extra.diagnostic === 'boolean' ? extra.diagnostic\r\n      : typeof this.diagnostic === 'boolean' ? this.diagnostic\r\n      : extra.skip || extra.todo ? false\r\n      : !ok\r\n\r\n    if (diagnostic) {\r\n      extra.diagnostic = true\r\n    }\r\n\r\n    if (extra.at === null) {\r\n      delete extra.at\r\n      delete extra.stack\r\n    } else if (\r\n      typeof extra.stack === 'string' &&\r\n      extra.stack &&\r\n      !extra.at\r\n    ) {\r\n      const parsed = stack.parseStack(extra.stack)\r\n      extra.at = parsed[0]\r\n      extra.stack = parsed.map(c => String(c) + '\\n').join('')\r\n    } else if (!extra.at && typeof fn === 'function') {\r\n      const showStack = !ok && !extra.skip && !extra.todo\r\n      const showAt = showStack || extra.diagnostic === true\r\n      if (showAt) {\r\n        const st = stack.capture(80, fn)\r\n        extra.at = st[0]\r\n        if (showStack) {\r\n          extra.stack = st.map(c => String(c)).join('\\n')\r\n        }\r\n      }\r\n    }\r\n\r\n    this.count = n\r\n    message = message + ''\r\n    const res: Result = { ok, message, extra }\r\n\r\n    this.#inheritFlags(extra)\r\n    const tp = new TestPoint(ok, message, extra)\r\n\r\n    // when we jump the queue, skip an extra line\r\n    if (front) {\r\n      tp.message = tp.message.trimEnd() + '\\n\\n'\r\n    }\r\n\r\n    // push to the front when we are occupied by a waiter and have ended,\r\n    // otherwise the relevant awaited assertion will be lost.\r\n    if (\r\n      this.#occupied &&\r\n      this.#occupied instanceof Waiter &&\r\n      this.#awaitingEnd\r\n    ) {\r\n      front = true\r\n    }\r\n\r\n    if (front) {\r\n      if (extra.tapChildBuffer || extra.tapChildBuffer === '') {\r\n        this.#writeSubComment(tp)\r\n        this.parser.write(extra.tapChildBuffer)\r\n      }\r\n      this.emit('result', res)\r\n      this.parser.write(tp.ok + ++this.#n + tp.message)\r\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\r\n        this.parser.write('Bail out! ' + message + '\\n')\r\n      }\r\n    } else {\r\n      this.queue.push(tp)\r\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\r\n        this.queue.push('Bail out! ' + message + '\\n')\r\n      }\r\n    }\r\n\r\n    this.#process()\r\n    if (this.#planEnd === this.count) {\r\n      if (!this.#awaitingEnd && !this.#occupied) this.#end(IMPLICIT)\r\n      else this.#awaitingEnd ||= IMPLICIT\r\n    }\r\n    this.#process()\r\n  }\r\n\r\n  /**\r\n   * Explicitly mark the test as completed, outputting the TAP plan line if\r\n   * needed.\r\n   *\r\n   * This is not required to be called if the test function returns a promise,\r\n   * or if a plan is explicitly declared and eventually fulfilled.\r\n   *\r\n   * @group Test Lifecycle Management\r\n   */\r\n  end(implicit?: typeof IMPLICIT): this {\r\n    this.#end(implicit)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * The leading `# Subtest` comment that introduces a child test\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  #writeSubComment<T extends TestPoint | Base>(p: T) {\r\n    // name will generally always be set\r\n    /* c8 ignore start */\r\n    const stn = p.name ? ': ' + esc(p.name) : ''\r\n    /* c8 ignore stop */\r\n    const comment = `# Subtest${stn}\\n`\r\n    this.parser.write(comment)\r\n  }\r\n  // end TAP otput generating methods\r\n\r\n  // flow control methods\r\n\r\n  /**\r\n   * Await the end of a Promise before proceeding.\r\n   * The supplied callback is called with the Waiter object.\r\n   *\r\n   * This is internal, used in some plugins when a promise must be awaited\r\n   * before proceeding. In normal test usage, it's usually best to simply use\r\n   * an async test function and `await` promises as normal.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  waitOn(\r\n    promise: Promise<any | void>,\r\n    cb?: (w: Waiter) => any,\r\n    expectReject: boolean = false,\r\n  ): Promise<void> {\r\n    const w = new Waiter(\r\n      promise,\r\n      w => {\r\n        assert.equal(this.#occupied, w)\r\n        if (cb) cb(w)\r\n        this.#occupied = null\r\n        this.#process()\r\n      },\r\n      expectReject,\r\n    )\r\n    // if the top of the queue is still the version line, we come\r\n    // in after that. otherwise, it should be the next thing processed.\r\n    if (this.queue[0] === VERSION) {\r\n      this.queue.shift()\r\n      this.queue.unshift(VERSION, w)\r\n    } else {\r\n      this.queue.unshift(w)\r\n    }\r\n    this.#process()\r\n    return w.promise\r\n  }\r\n\r\n  #end(implicit?: typeof IMPLICIT) {\r\n    if (this.#doingStdinOnly && implicit !== IMPLICIT) {\r\n      throw new Error('cannot explicitly end while in stdinOnly mode')\r\n    }\r\n    this.debug('END %s implicit=%j', this.name, implicit === IMPLICIT)\r\n    if (this.ended && implicit === IMPLICIT) {\r\n      this.debug('already ended, ignore implicit end')\r\n      return\r\n    }\r\n\r\n    // If onbeforeend returns a Promise, then wait for it to finish.\r\n    const obe = this.onbeforeend\r\n    if (obe && !this.#pushedBeforeEnd) {\r\n      this.debug('push obe')\r\n      this.#pushedBeforeEnd = true\r\n      if (!queueEmpty(this) || this.#occupied) {\r\n        this.queue.push(obe)\r\n        this.#process()\r\n      } else {\r\n        const ret = obe()\r\n        if (isPromise(ret)) {\r\n          // this will make the next section return this.#process()\r\n          this.waitOn(ret)\r\n        }\r\n      }\r\n    }\r\n\r\n    // beyond here we have to be actually done with things, or else\r\n    // the semantic checks on counts and such will be off.\r\n    if (!queueEmpty(this) || this.#occupied) {\r\n      this.debug(\r\n        '#end: queue not empty, or occupied',\r\n        this.#awaitingEnd,\r\n        this.#occupied,\r\n        this.queue,\r\n      )\r\n      if (!this.#awaitingEnd) {\r\n        this.#awaitingEnd = implicit === IMPLICIT ? IMPLICIT : true\r\n      }\r\n      return this.#process()\r\n    }\r\n\r\n    if (implicit !== IMPLICIT) {\r\n      if (this.#explicitEnded && this.#awaitingEnd !== true) {\r\n        this.debug('multi-end')\r\n        if (!this.#multiEndThrew) {\r\n          this.#multiEndThrew = true\r\n          const er = new Error(\r\n            'test end() method called more than once',\r\n          )\r\n          Error.captureStackTrace(er, this.#currentAssert || this.end)\r\n          er.cause = {\r\n            test: this.name,\r\n          }\r\n          this.threw(er)\r\n        }\r\n        return\r\n      }\r\n      this.debug('set #explicitEnded=true')\r\n      // switch from awaiting to processing the explicit end() call.\r\n      this.#explicitEnded = true\r\n      this.#awaitingEnd = false\r\n    }\r\n\r\n    if (this.#planEnd === -1 && !this.#doingStdinOnly) {\r\n      this.debug('END(%s) implicit plan', this.name, this.count)\r\n      const c =\r\n        this.count === 0 && !this.parent ? 'no tests found' : ''\r\n      this.plan(this.count, c, IMPLICIT)\r\n    } else if (!this.ended && this.#planEnd !== -1) {\r\n      const count = this.#endingAllSub ? this.count - 1 : this.count\r\n      if (this.#planEnd > count) {\r\n        this.fail(`test count(${count}) != plan(${this.#planEnd})`, {\r\n          found: count,\r\n          wanted: this.#planEnd,\r\n          at: this.#planAt,\r\n          stack: '',\r\n        })\r\n      }\r\n    }\r\n\r\n    this.debug('set ended=true')\r\n    this.ended = true\r\n    this.queue.push(EOF)\r\n    this.#process()\r\n  }\r\n\r\n  /**\r\n   * The full name of the test, starting with the main script name,\r\n   * and including all parent names.\r\n   */\r\n  get fullname(): string {\r\n    const main = (\r\n      mainScript('TAP') +\r\n      ' ' +\r\n      argv.slice(2).join(' ')\r\n    ).trim()\r\n    const n: string[] = [\r\n      (this.parent ? this.parent.fullname\r\n      : main === 'TAP' ? 'TAP'\r\n      : relative(cwd, main).replace(/\\\\/g, '/')\r\n      ).trim(),\r\n    ]\r\n    // tests will generally always have a name\r\n    /* c8 ignore start */\r\n    const myName = (this.name || '').trim()\r\n    /* c8 ignore stop */\r\n    if (myName) n.push(myName)\r\n    return n.join(' > ')\r\n  }\r\n\r\n  #process() {\r\n    if (this.#processing) {\r\n      return this.debug(' < already processing')\r\n    }\r\n    this.debug('\\nPROCESSING(%s)', this.name, this.queue.length)\r\n    this.#processing = true\r\n\r\n    while (!this.#occupied) {\r\n      const p = this.queue.shift()\r\n      if (!p) {\r\n        this.debug('> end of queue')\r\n        break\r\n      }\r\n      if (p instanceof Base) {\r\n        this.debug('> subtest in queue', p.name)\r\n        this.#processSubtest(p)\r\n      } else if (p === EOF) {\r\n        this.debug(' > EOF', this.name)\r\n        if (!this.#calledOnEOF) {\r\n          this.#calledOnEOF = true\r\n          // I AM BECOME EOF, DESTROYER OF STREAMS\r\n          this.debug('call onEOF', this.name)\r\n          const eofRet = this.onEOF()\r\n          if (isPromise(eofRet)) {\r\n            this.debug('onEOF is promise')\r\n            this.waitOn(eofRet, w => {\r\n              if (w.rejected) {\r\n                // threw on the parent, since we're EOFing already\r\n                this.debug('eofRet reject', w.value)\r\n                this.comment('error thrown in teardown')\r\n                this.threw(w.value)\r\n              }\r\n              this.queue.push(EOF)\r\n              this.#process()\r\n            })\r\n            break\r\n          }\r\n        }\r\n        this.debug('eof end parser', this.name)\r\n        this.parser.end()\r\n      } else if (p instanceof TestPoint) {\r\n        this.debug(' > TESTPOINT')\r\n        if (p.extra.tapChildBuffer || p.extra.tapChildBuffer === '') {\r\n          this.#writeSubComment(p)\r\n          this.parser.write(p.extra.tapChildBuffer)\r\n        }\r\n        this.emit('res', p.res)\r\n        this.parser.write(p.ok + ++this.#n + p.message)\r\n      } else if (typeof p === 'string') {\r\n        this.debug(' > STRING')\r\n        this.parser.write(p)\r\n      } else if (p instanceof Waiter) {\r\n        p.ready = true\r\n        this.#occupied = p\r\n        p.finish()\r\n      } else if (typeof p === 'function') {\r\n        this.debug(' > FUNCTION')\r\n        const ret = p()\r\n        if (isPromise(ret)) {\r\n          this.waitOn(ret)\r\n        }\r\n      } else if (Array.isArray(p)) {\r\n        this.debug(' > METHOD')\r\n        const m = p.shift() as keyof this\r\n        const fn = this[m] as (...a: any[]) => any\r\n        if (typeof fn !== 'function') {\r\n          this.debug(\r\n            ' > weird method not found in queue??',\r\n            m,\r\n            typeof this[m],\r\n          )\r\n          continue\r\n        }\r\n        const ret = fn.call(this, ...p)\r\n        if (isPromise(ret)) {\r\n          // returned promise\r\n          ret.then(\r\n            () => {\r\n              this.#processing = false\r\n              this.#process()\r\n            },\r\n            (er: unknown) => {\r\n              this.#processing = false\r\n              this.threw(er)\r\n            },\r\n          )\r\n          return\r\n        }\r\n        /* c8 ignore start */\r\n      } else {\r\n        throw new Error('weird thing got in the queue')\r\n      }\r\n      /* c8 ignore stop */\r\n    }\r\n\r\n    // waiters are serial\r\n    const ow = !!this.#occupied && this.#occupied instanceof Waiter\r\n    while (!this.#noparallel && !ow && this.pool.size < this.jobs) {\r\n      const p = this.subtests.shift()\r\n      if (!p) {\r\n        break\r\n      }\r\n\r\n      if (!p.buffered) {\r\n        this.#noparallel = true\r\n        break\r\n      }\r\n\r\n      this.debug('start subtest', p)\r\n      this.activeSubtests.add(p)\r\n      this.pool.add(p)\r\n      this.emit('subtestStart', p)\r\n      if (this.bailedOut) {\r\n        this.#onBufferedEnd(p)\r\n      } else {\r\n        // ts doesn't know this will always be set at this point\r\n        /* c8 ignore start */\r\n        p.options.jobId = this.#getJobId(p.options.childId || 0)\r\n        /* c8 ignore stop */\r\n        p.runMain(() => this.#onBufferedEnd(p))\r\n      }\r\n    }\r\n\r\n    this.debug(\r\n      'done processing',\r\n      this.queue,\r\n      this.#occupied,\r\n      this.#awaitingEnd,\r\n    )\r\n    this.#processing = false\r\n\r\n    // just in case any tests ended, and we have sync stuff still\r\n    // waiting around in the queue to be processed\r\n    if (!this.#occupied && this.queue.length) {\r\n      this.#process()\r\n    } else if (this.idle) {\r\n      this.debug(\r\n        'idle after #process',\r\n        this.#awaitingEnd,\r\n        this.#occupied,\r\n      )\r\n      if (this.#awaitingEnd) {\r\n        this.debug('awaited end in process', this.#awaitingEnd)\r\n        this.#end(\r\n          this.#awaitingEnd === IMPLICIT ? IMPLICIT : undefined,\r\n        )\r\n      }\r\n      // the root tap runner uses this event to know when it is safe to\r\n      // automatically end.\r\n      this.emit('idle')\r\n    }\r\n  }\r\n\r\n  // virtual \"worker\" id, even though it's just a pool\r\n  #getJobId(childId: number = 0) {\r\n    let j = childId % this.jobs\r\n    const start = j\r\n    while (this.#jobIds.has(j)) {\r\n      j = (j + 1) % this.jobs\r\n      // impossible because math\r\n      /* c8 ignore start */\r\n      if (j === start) return 0\r\n      /* c8 ignore stop */\r\n    }\r\n    this.#jobIds.add(j)\r\n    return j\r\n  }\r\n\r\n  /**\r\n   * True if the test is currently in an idle state\r\n   */\r\n  get idle() {\r\n    return (\r\n      !this.#processing &&\r\n      queueEmpty(this) &&\r\n      !this.pool.size &&\r\n      !this.subtests.length &&\r\n      !this.#occupied &&\r\n      // if we have a plan, don't autoend until the plan is complete.\r\n      (this.#planEnd === -1 || this.count === this.#planEnd)\r\n    )\r\n  }\r\n\r\n  #onBufferedEnd<T extends Base>(p: T) {\r\n    // ignore ends that come in after we've already aborted\r\n    if (this.ended && this.#endingAll) return\r\n    this.#jobIds.delete(p.options.jobId || 0)\r\n    p.results = p.results || new FinalResults(true, p.parser)\r\n    p.readyToProcess = true\r\n    const to = p.options.timeout\r\n    const dur =\r\n      to && p.passing() ?\r\n        Number(hrtime.bigint() - p.start) / 1e6\r\n      : null\r\n    if (dur && to && dur > to) {\r\n      p.timeout()\r\n    } else {\r\n      p.setTimeout(0)\r\n    }\r\n    this.debug(\r\n      '%s.#onBufferedEnd',\r\n      this.name,\r\n      p.name,\r\n      p.results.bailout,\r\n    )\r\n    p.options.tapChildBuffer = p.output || ''\r\n    p.options.stack = ''\r\n    if (p.time) p.options.time = p.time\r\n    if (this.#occupied === p) this.#occupied = null\r\n    this.pool.delete(p)\r\n    this.activeSubtests.delete(p)\r\n    p.deferred?.resolve(p.results)\r\n    this.emit('subtestEnd', p)\r\n    this.#process()\r\n  }\r\n\r\n  #onIndentedEnd<T extends Base>(p: T) {\r\n    // ignore ends that come in after we've already aborted\r\n    if (this.ended && this.#endingAll) return\r\n    this.debug('onIndentedEnd', p.name)\r\n    this.emit('subtestProcess', p)\r\n    // we'll generally already have a results by now, but just to be sure\r\n    /* c8 ignore start */\r\n    p.results = p.results || new FinalResults(true, p.parser)\r\n    /* c8 ignore stop */\r\n    this.#noparallel = false\r\n    const sti = this.subtests.indexOf(p)\r\n    if (sti !== -1) this.subtests.splice(sti, 1)\r\n    p.readyToProcess = true\r\n    p.options.time = p.time\r\n    const to = p.options.timeout\r\n    const now = hrtime.bigint()\r\n    const dur = to && p.passing() ? Number(now - p.start) / 1e6 : null\r\n    if (dur && to && dur > to) {\r\n      p.timeout()\r\n    } else {\r\n      p.setTimeout(0)\r\n    }\r\n    this.debug('#onIndentedEnd %s(%s)', this.name, p.name)\r\n    this.#occupied = null\r\n    this.debug('OIE(%s) >shift into queue', this.name, this.queue)\r\n    p.options.stack = ''\r\n\r\n    if (!p.silent || !p.passing()) {\r\n      if (p.silent) p.options.tapChildBuffer = p.output\r\n      this.#printResult(p.passing(), p.name, p.options, true)\r\n    }\r\n\r\n    this.debug('OIE(%s) shifted into queue', this.name, this.queue)\r\n    this.activeSubtests.delete(p)\r\n    p.deferred?.resolve(p.results)\r\n    this.emit('subtestEnd', p)\r\n    this.#process()\r\n  }\r\n\r\n  /**\r\n   * The main function that starts a test running. Generally no need\r\n   * to call this directly.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  main(cb: () => void) {\r\n    if (typeof this.options.timeout === 'number') {\r\n      this.setTimeout(this.options.timeout)\r\n    }\r\n\r\n    const done = (er?: Error) => {\r\n      this.donePromise = undefined\r\n      if (er) this.threw(er)\r\n\r\n      if (this.results || this.bailedOut) cb()\r\n      else\r\n        this.ondone = () => {\r\n          super.ondone()\r\n          cb()\r\n        }\r\n    }\r\n\r\n    // This bit of overly clever line-noise wraps the call to user-code\r\n    // in a try-catch. We can't rely on the domain for this yet, because\r\n    // the 'end' event can trigger a throw after the domain is unhooked,\r\n    // but before this is no longer the official \"active test\"\r\n    const ret = (() => {\r\n      if (!this.cb) return\r\n      try {\r\n        return this.cb(this.t || this)\r\n      } catch (er: any) {\r\n        if (!er || typeof er !== 'object') {\r\n          er = { error: er, at: null }\r\n        }\r\n        er.tapCaught = 'testFunctionThrow'\r\n        this.threw(er)\r\n      }\r\n    })()\r\n\r\n    if (ret && ret.then) {\r\n      this.donePromise = Object.assign(ret, {\r\n        tapAbortPromise: done,\r\n      })\r\n      ret.then(\r\n        () => {\r\n          this.debug(\r\n            ' > implicit end for promise?',\r\n            this.#occupied,\r\n            this.queue,\r\n            this.#explicitPlan,\r\n            this.#awaitingEnd,\r\n          )\r\n          // the promise has ended\r\n          // If we had an explicit plan that is now satisfied but was waiting\r\n          // for the promise to resolve, or if there was no explicit plan, end\r\n          // the test.\r\n          this.#promiseEnded = true\r\n          if (\r\n            // not already ended\r\n            !this.ended &&\r\n            ((!this.#explicitPlan && !this.#awaitingEnd) ||\r\n              (this.#explicitPlan &&\r\n                this.#awaitingEnd &&\r\n                this.count === this.#planEnd)) &&\r\n            !this.#occupied\r\n          ) {\r\n            // this should only be possible if an explicit end()\r\n            // has been called, because the only other source of an\r\n            // implicit end is this function right here.\r\n            this.#end(\r\n              /* c8 ignore start */\r\n              this.#awaitingEnd === IMPLICIT ? IMPLICIT : undefined,\r\n              /* c8 ignore stop */\r\n            )\r\n          } else {\r\n            this.debug('await implicit end')\r\n            this.#awaitingEnd = IMPLICIT\r\n          }\r\n          done()\r\n        },\r\n        (er: any) => {\r\n          if (!er || typeof er !== 'object') {\r\n            er = { error: er, at: null }\r\n          }\r\n          er.tapCaught = 'returnedPromiseRejection'\r\n          done(er)\r\n        },\r\n      )\r\n    } else {\r\n      done()\r\n    }\r\n\r\n    this.debug('MAIN post', this.name)\r\n  }\r\n\r\n  #processSubtest<T extends Base>(p: T) {\r\n    this.debug('processSubtest', p.name)\r\n    this.debug(' > subtest')\r\n    this.#occupied = p\r\n    if (!p.buffered) {\r\n      this.activeSubtests.add(p)\r\n      this.emit('subtestStart', p)\r\n      this.debug(' > subtest indented')\r\n      p.pipe(this.parser, { end: false })\r\n      if (!p.silent) this.#writeSubComment(p)\r\n      this.debug('calling runMain', p.name)\r\n      p.runMain(() => this.#onIndentedEnd(p))\r\n    } else if (p.readyToProcess) {\r\n      this.emit('subtestProcess', p)\r\n      this.debug(' > subtest buffered, finished')\r\n      // finished!  do the thing!\r\n      this.#occupied = null\r\n      if (!p.passing() || !p.silent) {\r\n        this.#printResult(p.passing(), p.name, p.options, true)\r\n      }\r\n    } else {\r\n      this.#occupied = p\r\n      this.debug(' > subtest buffered, unfinished', p)\r\n      // unfinished buffered test.\r\n      // nothing to do yet, just leave it there.\r\n      this.queue.unshift(p)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse stdin as the only tap stream (ie, not as a child test)\r\n   * If used, then no other subtests or assertions are allowed.\r\n   *\r\n   * @group Subtest Methods\r\n   */\r\n  stdinOnly<T extends BaseOpts>(\r\n    extra?: T & { tapStream?: Readable | Minipass<string | Buffer> },\r\n  ) {\r\n    const stream = (extra?.tapStream ?? process.stdin) as Minipass\r\n    /* c8 ignore start */\r\n    if (!stream) {\r\n      throw new Error('cannot read stdin without stdin stream')\r\n    }\r\n    /* c8 ignore stop */\r\n\r\n    if (\r\n      this.queue.length !== 1 ||\r\n      this.queue[0] !== VERSION ||\r\n      this.#processing ||\r\n      this.results ||\r\n      this.#occupied ||\r\n      this.pool.size ||\r\n      this.subtests.length\r\n    ) {\r\n      throw new Error('Cannot use stdinOnly on a test in progress')\r\n    }\r\n\r\n    this.#doingStdinOnly = true\r\n    this.queue.length = 0\r\n    this.parser.on('child', p => {\r\n      // pretend to be a rooted parser, so it gets counts.\r\n      p.root = p\r\n      const t = new Base({\r\n        name: p.name,\r\n        parent: this,\r\n        parser: p,\r\n        bail: p.bail,\r\n        strict: p.strict,\r\n        omitVersion: p.omitVersion,\r\n        preserveWhitespace: p.preserveWhitespace,\r\n        childId: this.#nextChildId++,\r\n      })\r\n      this.emit('subtestAdd', t)\r\n      this.activeSubtests.add(t)\r\n      this.emit('subtestStart', t)\r\n      this.emit('subtestProcess', t)\r\n      p.on('complete', () => {\r\n        t.time = p.time\r\n        this.activeSubtests.delete(t)\r\n        this.emit('subtestEnd', t)\r\n      })\r\n    })\r\n    stream.pipe(this.parser)\r\n    stream.resume()\r\n  }\r\n\r\n  /**\r\n   * Mount a subtest, using this Test object as a harness.\r\n   * Exposed so that it can be used by some builtin plugins, but perhaps\r\n   * the least convenient way imaginable to create subtests. Just use\r\n   * `t.test()` to do that, it's much easier.\r\n   *\r\n   * @group Subtest Methods\r\n   *\r\n   * @internal\r\n   */\r\n  sub<T extends Base, O extends BaseOpts>(\r\n    Class: { new (options: O): T },\r\n    extra: O | TestBaseOpts = {},\r\n    caller: (...a: any[]) => unknown = this.sub,\r\n  ): PromiseWithSubtest<T> {\r\n    if (this.bailedOut) {\r\n      return Object.assign(Promise.resolve(null), {\r\n        subtest: null,\r\n      })\r\n    }\r\n\r\n    if (this.results || this.ended) {\r\n      const msg =\r\n        this.#promiseEnded ?\r\n          'cannot create subtest after parent promise resolves'\r\n        : this.#explicitEnded ? 'subtest after parent test end()'\r\n        : this.#explicitPlan ? 'test count exceeds plan'\r\n        : /* c8 ignore start */\r\n          'cannot create subtest after parent test ends'\r\n      /* c8 ignore stop */\r\n      const er = new Error(msg)\r\n      Error.captureStackTrace(er, caller)\r\n      this.threw(er)\r\n      return Object.assign(Promise.resolve(null), {\r\n        subtest: null,\r\n      })\r\n    }\r\n\r\n    extra.childId = this.#nextChildId++\r\n    if (this.shouldSkipChild(extra)) {\r\n      this.currentAssert = this.sub\r\n      this.pass(extra.name || '', extra)\r\n      return Object.assign(Promise.resolve(null), {\r\n        subtest: null,\r\n      })\r\n    }\r\n\r\n    extra.indent = '    '\r\n    if (extra.buffered === undefined && !extra.silent) {\r\n      extra.buffered = this.jobs > 1\r\n    }\r\n\r\n    extra.parent = this\r\n    if (!extra.at && extra.at !== null) {\r\n      const st = stack.capture(80, caller)\r\n      extra.at = st[0]\r\n      extra.stack = st.map(c => String(c)).join('\\n')\r\n    }\r\n\r\n    this.#inheritFlags(extra)\r\n\r\n    const t = new Class(extra as O)\r\n\r\n    this.queue.push(t)\r\n    this.subtests.push(t)\r\n    this.emit('subtestAdd', t)\r\n    // this would make its way here eventually anyway, but the\r\n    // test bailing out might be waiting for its turn in the pool\r\n    // to be processed, and bailout should happen ASAP.\r\n    t.on('bailout', reason => this.bailout(reason))\r\n\r\n    const d = new Deferred<FinalResults>()\r\n    t.deferred = d\r\n    this.#process()\r\n    return Object.assign(d.promise, { subtest: t })\r\n  }\r\n\r\n  /**\r\n   * Method called when an unrecoverable error is encountered in a test.\r\n   *\r\n   * Typically, in tests you would not call this, you'd just actually throw\r\n   * an error.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  threw(\r\n    er: any,\r\n    extra?: Extra,\r\n    proxy: boolean = false,\r\n  ): Extra | void | undefined {\r\n    this.debug('TestBase.threw', this.name, er.message)\r\n    // this can happen if a beforeEach throws.  capture the error here\r\n    // and raise it once we've started the test officially.\r\n    if (this.parent && !this.started) {\r\n      this.cb = () => {\r\n        this.threw(er)\r\n        this.end()\r\n      }\r\n      return\r\n    }\r\n\r\n    // suppress the callsite for non-error throws, since\r\n    // it'll always just be useless noise pointing back here.\r\n    if (typeof er === 'string') {\r\n      er = { message: er, at: null }\r\n    }\r\n\r\n    if (this.name && !proxy) {\r\n      er.test = this.name\r\n    }\r\n    if (!proxy) {\r\n      extra = extraFromError(er, extra)\r\n    }\r\n    this.debug('T.t call Base.threw', this.name, er, extra)\r\n    const ended =\r\n      !!this.results ||\r\n      // should be impossible, when we hit the plan end, we end\r\n      /* c8 ignore start */\r\n      (this.#explicitPlan && this.count === this.#planEnd)\r\n    /* c8 ignore stop */\r\n    this.parser.ok = false\r\n    const threwInfo = super.threw(er, extra, proxy, ended)\r\n\r\n    // Handle the failure here, but only if we (a) don't have\r\n    // results yet (indicating an end) and (b) are not currently\r\n    // at the plan end (which would mean that any failure is\r\n    // ignored to prevent infinite regress in \"plan exceeded\"\r\n    // failures)\r\n    if (!ended && threwInfo) {\r\n      const msg = threwInfo.message as string\r\n      extra ??= { at: null }\r\n      if (this.parent && extra.test === this.name) {\r\n        // remove extraneous indicator if it's already nested\r\n        // in a TAP subtest\r\n        delete extra.test\r\n      }\r\n      if (extra.error === msg) {\r\n        delete extra.error\r\n      }\r\n      if (!extra.stack && er.stack && typeof er.stack === 'string') {\r\n        // trim off the first line if it looks like the standard\r\n        // error `Name: message` line.\r\n        /* c8 ignore start */\r\n        const f = `${er.name || 'Error'}: ${er.message}\\n`\r\n        const st =\r\n          er.stack.startsWith(f) ?\r\n            er.stack.substring(f.length)\r\n          : er.stack\r\n        /* c8 ignore stop */\r\n        const p = stack.parseStack(st)\r\n        extra.at = p[0] || null\r\n        extra.stack = p.map(c => String(c) + '\\n').join('')\r\n      }\r\n      if (!extra.at && !extra.stack) extra.at = null\r\n      this.fail(msg, extra)\r\n      if (this.ended || this.#awaitingEnd) {\r\n        this.ended = false\r\n        this.#awaitingEnd = false\r\n        this.end(IMPLICIT)\r\n      }\r\n    }\r\n    if (this.#occupied && this.#occupied instanceof Waiter) {\r\n      this.#occupied.abort(\r\n        Object.assign(\r\n          new Error('error thrown while awaiting Promise'),\r\n          { thrown: er },\r\n        ),\r\n      )\r\n      this.#occupied = null\r\n    }\r\n    if (!proxy) {\r\n      this.#end(IMPLICIT)\r\n      this.#processing = false\r\n    }\r\n\r\n    this.#process()\r\n    /* c8 ignore start */\r\n    this.donePromise?.tapAbortPromise?.()\r\n    /* c8 ignore stop */\r\n  }\r\n\r\n  /**\r\n   * Method called when the parser encounters a bail out\r\n   *\r\n   * To listen to bailout events, listen to the\r\n   * {@link @tapjs/core!base.TapBaseEvents#bailout} event:\r\n   *\r\n   * ```ts\r\n   * t.on('bailout', message => {\r\n   *   // test bailed out!\r\n   * })\r\n   * ```\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  onbail(message?: string) {\r\n    super.onbail(message)\r\n    this.#end(IMPLICIT)\r\n    if (!this.parent) {\r\n      this.endAll()\r\n    } else {\r\n      throw 'bailout'\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when a test times out or bails out, or the process ends,\r\n   * marking all currently active or queued subtests as incomplete.\r\n   *\r\n   * No need to ever call this directly, exposed so that it can be extended by\r\n   * {@link @tapjs/core!spawn.Spawn} and {@link @tapjs/core!worker.Worker},\r\n   * which have special behaviors that are required when a process hangs\r\n   * indefinitely.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  endAll(sub: boolean = false) {\r\n    if (this.bailedOut) return\r\n    this.#endingAll = true\r\n    this.#endingAllSub = sub\r\n\r\n    // in the case of the root TAP test object, we might sometimes\r\n    // call endAll on a bailing-out test, as the process is ending\r\n    // In that case, we WILL have a this.occupied and a full queue\r\n    // These cases are very rare to encounter in other Test objs tho\r\n    this.#processing = true\r\n    if (this.#occupied) {\r\n      const p = this.#occupied\r\n\r\n      if (p instanceof Waiter) p.abort(new Error('test unfinished'))\r\n      else if (typeof (p as TestBase).endAll === 'function') {\r\n        // first try to end explicitly, then endAll if that didn't work\r\n        const pt = p as TestBase\r\n        pt.endAll(true)\r\n      } else p.parser.abort('test unfinished')\r\n      this.#occupied = null\r\n    } else if (sub) {\r\n      this.#process()\r\n      if (\r\n        queueEmpty(this) &&\r\n        (this.#planEnd === -1 || this.count < this.#planEnd)\r\n      ) {\r\n        const options = Object.assign({}, this.options)\r\n        options.test = this.name\r\n        this.fail('test unfinished', options)\r\n      }\r\n    }\r\n\r\n    this.donePromise?.tapAbortPromise?.()\r\n\r\n    for (let i = 0; i < this.queue.length; i++) {\r\n      const p = this.queue[i]\r\n      if (p instanceof Base && !p.readyToProcess) {\r\n        const msg = `child test left in queue: ${p.name}`\r\n        delete p.options.skip\r\n        delete p.options.todo\r\n        this.queue[i] = new TestPoint(false, msg, p.options)\r\n        this.count++\r\n      }\r\n    }\r\n\r\n    this.#processing = false\r\n    this.#process()\r\n    this.end(IMPLICIT)\r\n    this.#process()\r\n  }\r\n\r\n  /**\r\n   * Return true if the child test represented by the options object\r\n   * should be skipped.  Extended by the `@tapjs/filter` plugin.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  shouldSkipChild<O extends BaseOpts>(\r\n    extra: O | TestBaseOpts | BaseOpts,\r\n  ): boolean {\r\n    return !!(extra.skip || extra.todo)\r\n  }\r\n}\r\n"]}