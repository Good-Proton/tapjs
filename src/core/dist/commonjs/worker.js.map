{"version":3,"file":"worker.js","sourceRoot":"","sources":["../../src/worker.ts"],"names":[],"mappings":"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","sourcesContent":["import { Base, TapBaseEvents } from './base.js'\r\nimport { cwd, env } from './proc.js'\r\n\r\nimport { format } from 'node:util'\r\nimport { Worker as NodeWorker } from 'node:worker_threads'\r\nimport { FinalResults } from 'tap-parser'\r\nimport { Extra } from './index.js'\r\nimport { TestBaseOpts } from './test-base.js'\r\nimport { throwToParser } from './throw-to-parser.js'\r\n\r\n/**\r\n * Events emitted by {@link @tapjs/core!worker.Worker} instances\r\n */\r\nexport interface WorkerEvents extends TapBaseEvents {\r\n  process: [NodeWorker]\r\n}\r\n\r\n/**\r\n * Options that can be provided to a {@link @tapjs/core!worker.Worker}\r\n */\r\nexport interface WorkerOpts extends TestBaseOpts {\r\n  /**\r\n   * Data that will be available on `t.workerData` on the root\r\n   * {@link @tapjs/core!tap.TAP} object in the worker thread.\r\n   */\r\n  workerData?: any\r\n  /**\r\n   * Environment variables that are set in the worker thread\r\n   */\r\n  env?: { [k: string]: string } | NodeJS.ProcessEnv\r\n  /**\r\n   * If true, treat the `filename` argument as a string of JavaScript to\r\n   * be evaluated by Node in the worker thread.\r\n   */\r\n  eval?: boolean\r\n  /**\r\n   * Set internally to the numeric thread identifier once the worker is\r\n   * instantiated.\r\n   *\r\n   * @internal\r\n   */\r\n  threadId?: number\r\n}\r\n\r\n/**\r\n * Class representing a TAP generating node worker thread\r\n *\r\n * Instantiated by `t.worker()`, typically.\r\n *\r\n * @internal\r\n */\r\nexport class Worker extends Base<WorkerEvents> {\r\n  declare options: WorkerOpts\r\n\r\n  eval: boolean\r\n  filename: string\r\n  cb?: () => void\r\n  worker: null | NodeWorker = null\r\n  #childId: string\r\n  env: { [k: string]: string } | NodeJS.ProcessEnv\r\n  // doesn't have to be cryptographically secure, just a gut check\r\n  #childKey: string = String(Math.random())\r\n  #timedOut?: { expired?: string }\r\n  #workerEnded: boolean = false\r\n\r\n  constructor(options: WorkerOpts) {\r\n    const { filename } = options\r\n    if (!filename) {\r\n      throw new TypeError('no filename provided for t.worker()')\r\n    }\r\n    options.name =\r\n      options.name || Worker.procName(filename, !!options.eval)\r\n    super(options)\r\n    this.#childId = String(options.childId || env.TAP_CHILD_ID || '1')\r\n    this.filename = filename\r\n    this.eval = !!options.eval\r\n    this.env = {\r\n      ...(options.env || env),\r\n      TAP: '1',\r\n      TAP_CHILD_ID: this.#childId,\r\n      TAP_BAIL: this.bail ? '1' : '0',\r\n      TAP_CHILD_KEY: this.#childKey,\r\n    }\r\n    this.bail = !!options.bail\r\n  }\r\n\r\n  main(cb: () => void) {\r\n    this.cb = cb\r\n    this.setTimeout(this.options.timeout || 0)\r\n\r\n    this.parser.on('comment', c => {\r\n      const tomatch = c.match(/# timeout=([0-9]+)\\n$/)\r\n      if (tomatch) {\r\n        this.setTimeout(+tomatch[1])\r\n      }\r\n    })\r\n\r\n    this.parent?.emit('worker', this)\r\n    const options = {\r\n      ...this.options,\r\n      eval: this.eval,\r\n      stdout: true,\r\n      env: this.env,\r\n    }\r\n    this.emit('preprocess', options)\r\n    this.worker = new NodeWorker(this.filename, options)\r\n    this.worker.stdout.pipe(this.parser)\r\n    this.worker.on('error', e => this.threw(e))\r\n    this.worker.on('exit', () => this.#onworkerexit())\r\n    this.worker.on('message', msg => {\r\n      const m = msg as {\r\n        key: string\r\n        child: string\r\n        setTimeout: number\r\n      }\r\n      if (\r\n        m &&\r\n        m.key === this.#childKey &&\r\n        m.child === this.#childId\r\n      ) {\r\n        this.setTimeout(m.setTimeout)\r\n        return\r\n      }\r\n      this.comment(...(Array.isArray(msg) ? msg : [msg]))\r\n    })\r\n    this.emit('process', this.worker)\r\n  }\r\n\r\n  threw(er: any, extra?: Extra): Extra | void | undefined {\r\n    return throwToParser(this.parser, super.threw(er, extra))\r\n  }\r\n\r\n  #onworkerexit() {\r\n    this.#workerEnded = true\r\n    if (this.results) this.#callCb()\r\n  }\r\n\r\n  timeout(options: { expired?: string } = { expired: this.name }) {\r\n    this.#timedOut = options\r\n    // try to send the timeout signal.  If the child test process is\r\n    // using node-tap as the test runner, and not caught in a busy\r\n    // loop, it will trigger a dump of outstanding handles and refs.\r\n    // If that doesn't do the job, then we fall back to thread termination.\r\n    const worker = this.worker\r\n    if (worker) {\r\n      try {\r\n        worker.postMessage({\r\n          tapAbort: 'timeout',\r\n          key: this.#childKey,\r\n          child: this.childId,\r\n        })\r\n        /* c8 ignore start */\r\n      } catch {}\r\n      // need to ignore this bit because there's no way (by design) to\r\n      // ignore the timeout signal, but it's theoretically possible that\r\n      // it could be dropped or some busy-wait process prevents it from\r\n      // being processed.\r\n      const t = setTimeout(() => {\r\n        // try to give it a chance to note the timeout and report handles\r\n        try {\r\n          worker.terminate()\r\n        } catch (er) {}\r\n      }, 500)\r\n      if (t.unref) t.unref()\r\n      /* c8 ignore stop */\r\n    }\r\n  }\r\n\r\n  oncomplete(results: FinalResults) {\r\n    this.results = results\r\n    if (this.#workerEnded) this.#callCb()\r\n  }\r\n\r\n  #callCb() {\r\n    if (this.#timedOut) super.timeout(this.#timedOut)\r\n    const { results } = this\r\n    /* c8 ignore start */\r\n    if (!results) {\r\n      throw new Error('worker calling cb before parser ended??')\r\n    }\r\n    /* c8 ignore stop */\r\n    // worker closing with no tests is treated as a skip.\r\n    if (results.plan && results.plan.skipAll) {\r\n      this.options.skip = results.plan.skipReason || true\r\n    }\r\n    super.oncomplete(results)\r\n\r\n    const { cb } = this\r\n    /* c8 ignore start */\r\n    if (!cb) {\r\n      throw new Error('tap worker finished before receiving cb??')\r\n    }\r\n    /* c8 ignore stop */\r\n    cb()\r\n  }\r\n\r\n  comment(...args: any[]) {\r\n    const body = format(...args)\r\n    const message =\r\n      ('# ' + body.split(/\\r?\\n/).join('\\n# ')).trim() + '\\n'\r\n    // it's almost impossible to send a message that will arrive\r\n    // AFTER the stdout closes, as this only happens when the worker\r\n    // thread closes, but it is theoretically possible, since messages\r\n    // are asynchronous.\r\n    /* c8 ignore start */\r\n    if (this.parser.results) {\r\n      if (this.parent && !this.parent.results) {\r\n        this.parent.parser.write(message)\r\n      } else {\r\n        console.log(message.trimEnd())\r\n      }\r\n    } else {\r\n      /* c8 ignore stop */\r\n      this.parser.write(message)\r\n    }\r\n  }\r\n\r\n  endAll() {\r\n    if (this.worker) {\r\n      this.parser.abort('test unfinished')\r\n      this.worker.terminate()\r\n    }\r\n  }\r\n\r\n  static procName(filename: string, ev: boolean) {\r\n    const pref = '<worker> node'\r\n    if (ev) return `${pref} -e <inline code>`\r\n    if (filename.indexOf(cwd) === 0) {\r\n      filename = './' + filename.substring(cwd.length + 1)\r\n    }\r\n    filename = filename.replace(/\\\\/g, '/')\r\n    return `${pref} ${filename}`\r\n  }\r\n}\r\n"]}