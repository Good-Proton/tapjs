{"version":3,"file":"base.js","sourceRoot":"","sources":["../../src/base.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * The base class that is extended by all TAP-generating classes\r\n *\r\n * @module\r\n */\r\n\r\nimport { Domain } from 'async-hook-domain'\r\nimport { AsyncResource } from 'async_hooks'\r\nimport { Minipass } from 'minipass'\r\nimport { hrtime } from 'node:process'\r\nimport { format } from 'node:util'\r\nimport { FinalResults, Parser, Result, TapError } from 'tap-parser'\r\nimport { Deferred } from 'trivial-deferred'\r\nimport { Counts } from './counts.js'\r\nimport { diags } from './diags.js'\r\nimport { extraFromError } from './extra-from-error.js'\r\nimport type { Extra, TestBase } from './index.js'\r\nimport { Lists } from './lists.js'\r\nimport { messageFromError } from './message-from-error.js'\r\n\r\nconst unsetContext = Symbol('TAP.context unset')\r\n\r\n/**\r\n * Events emitted by the Base class\r\n */\r\nexport interface TapBaseEvents extends Minipass.Events<string> {\r\n  /**\r\n   * emitted when a timeout occurs\r\n   */\r\n  timeout: [threw?: Extra]\r\n  /**\r\n   * emitted when the test bails out\r\n   */\r\n  bailout: [reason?: string]\r\n  /**\r\n   * emitted when the test is complete\r\n   */\r\n  complete: [results: FinalResults]\r\n}\r\n\r\n/**\r\n * Wrapper for the async-hook-domain that catches errors thrown during\r\n * test operation.\r\n *\r\n * @see {@link https://npmjs.com/async-hook-domain}\r\n */\r\nexport class TapWrap extends AsyncResource {\r\n  test: Base\r\n  onDestroy?: () => void\r\n  constructor(test: Base) {\r\n    super(`tap.${test.constructor.name}`)\r\n    this.test = test\r\n  }\r\n  emitDestroy() {\r\n    this.onDestroy?.()\r\n    super.emitDestroy()\r\n    return this\r\n  }\r\n}\r\n\r\nconst debug =\r\n  (name: string) =>\r\n  (...args: any[]) => {\r\n    const prefix = `TAP ${process.pid} ${name}: `\r\n    const msg = format(...args).trim()\r\n    console.error(prefix + msg.split('\\n').join(`\\n${prefix}`))\r\n  }\r\n\r\n/**\r\n * A number indicating an amount of milliseconds\r\n */\r\nexport type MILLISECONDS = number\r\n\r\n/**\r\n * Options that may be passed to any TAP-generating class\r\n */\r\nexport interface BaseOpts extends Extra {\r\n  /**\r\n   * Bail out on the first failure\r\n   */\r\n  bail?: boolean\r\n  /**\r\n   * Treat any unknown non-TAP data as an error\r\n   * May be set at run-time by the TAP stream using `pragma +strict`\r\n   */\r\n  strict?: boolean\r\n  /**\r\n   * Do not emit the `TAP version 14` line.\r\n   */\r\n  omitVersion?: boolean\r\n  /**\r\n   * Do not elide empty lines and other unnecessary whitespace\r\n   */\r\n  preserveWhitespace?: boolean\r\n  /**\r\n   * Skip this test entirely, emitting a `# SKIP` directive\r\n   */\r\n  skip?: boolean | string\r\n  /**\r\n   * Mark this test as to be done later, emitting a `# TODO` directive\r\n   */\r\n  todo?: boolean | string\r\n  /**\r\n   * Amount of time in milliseconds before this test times out\r\n   */\r\n  timeout?: MILLISECONDS\r\n\r\n  /**\r\n   * track passes in the results lists, default false\r\n   */\r\n  passes?: boolean\r\n\r\n  /**\r\n   * treat todo tests as failures, default false\r\n   */\r\n  failTodo?: boolean\r\n\r\n  /**\r\n   * treat skip tests as failures, default false\r\n   */\r\n  failSkip?: boolean\r\n\r\n  /**\r\n   * treat only:true tests as failures, default false\r\n   */\r\n  failOnly?: boolean\r\n\r\n  /**\r\n   * The amount of time that this test took to complete.\r\n   *\r\n   * Typically, this is not set explicitly, but inferred from the actual\r\n   * time spent. However in some cases, it may be reported by the\r\n   * top-level `# time=...` comment in a TAP subprocess stream.\r\n   */\r\n  time?: number\r\n  /**\r\n   * The TAP data from a buffered test.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  tapChildBuffer?: string\r\n  /**\r\n   * The stack where this test was initiated\r\n   */\r\n  stack?: string\r\n\r\n  /**\r\n   * Parent test of this test\r\n   */\r\n  parent?: Base | TestBase\r\n  /**\r\n   * The name of this test\r\n   */\r\n  name?: string\r\n  /**\r\n   * Numeric identifier attached to child tests. Most of the time, this is\r\n   * set based on the `TAP_CHILD_ID` environment variable.\r\n   */\r\n  childId?: number\r\n  /**\r\n   * Any arbitrary data that is provided to this test object. Often, this\r\n   * is set in a `t.before()` or `t.beforeEach()` method. Scalar values\r\n   * are inherited by child tests. Object values are extended in child\r\n   * tests using `Object.create()`.\r\n   *\r\n   * If not set in the options, this is initialized to a null-prototyped\r\n   * object, so that usage like `t.context.foo = 'bar'` will work as expected.\r\n   *\r\n   * This is initialized and set on the Test object in the `runMain` method,\r\n   * *not* at construction time. If set explicitly on the Test object in a\r\n   * `before` hook, then any context specified on options or inherited from\r\n   * the parent test will be ignored.\r\n   */\r\n  context?: any\r\n  /**\r\n   * Number of spaces that this test is indented.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  indent?: string\r\n  /**\r\n   * True to output LOTS AND LOTS of noisy debugging information.\r\n   * Set at the top level by the `TAP_DEBUG` environment variable.\r\n   */\r\n  debug?: boolean\r\n  /**\r\n   * Parser to use for this TAP stream.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  parser?: Parser\r\n  /**\r\n   * True if this test should be buffered, and only processed once\r\n   * complete.\r\n   *\r\n   * Defaults to true when `t.jobs` is set to a value greater than 1.\r\n   *\r\n   * If set false in that case, then the test will NOT be run in parallel,\r\n   * so this provides a way to control the parallelism within a test suite.\r\n   */\r\n  buffered?: boolean\r\n\r\n  /**\r\n   * Setting silent:true in a subtest option makes it completely excluded\r\n   * from test output, UNLESS it fails.\r\n   *\r\n   * This was used historically for a few things which are now implemented\r\n   * with a more sophisticated promise management system, but can be handy in\r\n   * some rare situations.\r\n   */\r\n  silent?: boolean\r\n}\r\n\r\nexport class Base<\r\n  Events extends TapBaseEvents = TapBaseEvents,\r\n> extends Minipass<string, string, Events> {\r\n  /**\r\n   * Set upon test completion when a child test is ready to be processed by its\r\n   * parent.\r\n   */\r\n  readyToProcess: boolean = false\r\n  /**\r\n   * Options provided to this test\r\n   */\r\n  options: BaseOpts\r\n  /**\r\n   * number of spaces to indent the TAP stream\r\n   */\r\n  indent: string\r\n  /**\r\n   * TapWrap AsyncResource that limits the async-hook-domain\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  hook: TapWrap\r\n  // this actually is deterministically set in the ctor, but\r\n  // in the hook, so tsc doesn't see it.\r\n  /**\r\n   * the async-hook-domain that catches throws and Promise rejections\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  hookDomain!: Domain\r\n  /**\r\n   * The timer that fires when the test times out\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  timer?: NodeJS.Timeout\r\n\r\n  /**\r\n   * Set to true when the test times out, so its failure status can be\r\n   * determined later.\r\n   */\r\n  timedOut: boolean = false\r\n  /**\r\n   * The tap parser attached to this TAP stream\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  parser: Parser\r\n  /**\r\n   * Method that writes to stderr when `debug: true` is set in the options,\r\n   * or no-ops otherwise\r\n   */\r\n  debug: (...args: any[]) => void\r\n  /**\r\n   * The count of all assertions that this stream emitted\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  counts: Counts\r\n  /**\r\n   * Lists of todo, skip, and failure test points. If `passes: true` is\r\n   * set in the options, then passing test points will also be tracked.\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  lists: Lists\r\n  /**\r\n   * the name of this test\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  name: string\r\n  /**\r\n   * Set on completion. The results of the test run.\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  results?: FinalResults\r\n  /**\r\n   * Parent test of this TAP stream\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  parent?: Base | TestBase\r\n\r\n  /**\r\n   * Nesting level, for serialization to node test runner\r\n   *\r\n   * Note that this is zero for parent-less tests, and *also* zero\r\n   * for the first level of children.\r\n   */\r\n  nestingLevel: number = 0\r\n\r\n  /**\r\n   * Bail out on the first failed test point\r\n   */\r\n  bail: boolean\r\n  /**\r\n   * Treat non-TAP data as an error.\r\n   * May be set with `pragma +strict` in the TAP stream, or unset with\r\n   * `pragma: -strict`.\r\n   */\r\n  strict: boolean\r\n  /**\r\n   * Do not emit the `TAP version 14` line at the start\r\n   */\r\n  omitVersion: boolean\r\n  /**\r\n   * Do not elide extraneous whitespace and empty lines.\r\n   */\r\n  preserveWhitespace: boolean\r\n\r\n  /**\r\n   * Unrecoverable TAP protocol errors in the stream\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  errors: TapError[]\r\n\r\n  /**\r\n   * Numeric identifier for this test\r\n   */\r\n  childId: number\r\n\r\n  /**\r\n   * Any arbitrary data that is provided to this test object. Often, this\r\n   * is set in a `t.before()` or `t.beforeEach()` method. Scalar values\r\n   * are inherited by child tests. Object values are extended in child\r\n   * tests using `Object.create()`.\r\n   */\r\n  #context: any = unsetContext\r\n  get context() {\r\n    if (this.#context === unsetContext)\r\n      this.#context = Object.create(null)\r\n    return this.#context\r\n  }\r\n  set context(c: any) {\r\n    this.#context = c\r\n  }\r\n\r\n  /**\r\n   * the TAP stream data for buffered tests\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  output: string\r\n\r\n  /**\r\n   * True if this test should be buffered and only processed on completion\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  buffered: boolean\r\n\r\n  /**\r\n   * True if this test emitted a bailout\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  bailedOut: string | boolean\r\n\r\n  /**\r\n   * high resolution bigint time when this test started\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  start: bigint\r\n  #started: boolean = false\r\n\r\n  /**\r\n   * Amount of time in milliseconds that this test took to complete.\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  time: MILLISECONDS\r\n\r\n  /**\r\n   * High resolution time in ns that this test took to complete.\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  hrtime: bigint\r\n\r\n  /**\r\n   * True if this test should be buffered and only emit data if it fails\r\n   */\r\n  silent: boolean\r\n\r\n  /**\r\n   * A `Deferred` promise wrapper that is resolved when this test completes.\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  deferred?: Deferred<FinalResults>\r\n\r\n  #printedOutput: boolean = false\r\n\r\n  #writable: boolean = true\r\n\r\n  constructor(options: BaseOpts = {}) {\r\n    super({ encoding: 'utf8' })\r\n    // always use the constructor name as toStringTag, so we get\r\n    // [object Test] or [object TAP] and the appropriate typeName\r\n    // in stack traces.\r\n    Object.defineProperty(this, Symbol.toStringTag, {\r\n      value: this.constructor.name,\r\n      configurable: true,\r\n    })\r\n    // all tap streams are sync string minipasses\r\n    this.hook = new TapWrap(this)\r\n    this.options = options\r\n    this.counts = new Counts()\r\n    this.lists = new Lists()\r\n\r\n    this.silent = !!options.silent\r\n\r\n    this.bail = !!options.bail\r\n    this.strict = !!options.strict\r\n    this.omitVersion = !!options.omitVersion\r\n    this.preserveWhitespace = options.preserveWhitespace !== false\r\n    this.buffered =\r\n      this.silent ?\r\n        options.buffered === undefined\r\n      : !!options.buffered\r\n    this.bailedOut = false\r\n    this.errors = []\r\n    this.parent = options.parent\r\n    if (this.parent?.parent) {\r\n      this.nestingLevel = this.parent.nestingLevel + 1\r\n    }\r\n\r\n    this.time = 0\r\n    this.hrtime = 0n\r\n    this.start = 0n\r\n    this.childId = options.childId || 0\r\n    // do we need this?  couldn't we just call the Minipass\r\n    this.output = ''\r\n    this.indent = options.indent || ''\r\n    this.name = options.name || '(unnamed test)'\r\n    this.hook.runInAsyncScope(() => {\r\n      this.hookDomain = new Domain((er, type) => {\r\n        /* c8 ignore start */\r\n        if (!er || typeof er !== 'object') {\r\n          er = { error: er }\r\n        }\r\n        /* c8 ignore stop */\r\n        ;(er as { tapCaught?: string }).tapCaught = type\r\n        this.threw(er)\r\n      })\r\n    })\r\n    this.debug = !!options.debug ? debug(this.name) : () => {}\r\n\r\n    this.parser =\r\n      options.parser ||\r\n      new Parser({\r\n        bail: this.bail,\r\n        strict: this.strict,\r\n        omitVersion: this.omitVersion,\r\n        preserveWhitespace: this.preserveWhitespace,\r\n        passes: this.options.passes,\r\n        name: this.name,\r\n      })\r\n    this.#setupParser()\r\n\r\n    // ensure that a skip or todo on a child class reverts\r\n    // back to Base's no-op main.\r\n    if (options.skip || options.todo) {\r\n      this.main = Base.prototype.main\r\n    }\r\n  }\r\n\r\n  #isFilterSkip(res: Result) {\r\n    return (\r\n      typeof res.skip === 'string' &&\r\n      /^filter: (only|\\/.*\\/)$/.test(res.skip)\r\n    )\r\n  }\r\n\r\n  #onParserResult(res: Result) {\r\n    this.counts.total++\r\n    const type =\r\n      res.todo ? 'todo'\r\n      : res.skip ? 'skip'\r\n      : !res.ok ? 'fail'\r\n      : 'pass'\r\n    this.counts[type]++\r\n    if (type === 'pass' && this.options.passes) {\r\n      this.lists.pass.push(res)\r\n    } else if (type === 'todo') {\r\n      this.lists.todo.push(res)\r\n    } else if (type === 'skip') {\r\n      if (!this.#isFilterSkip(res)) this.lists.skip.push(res)\r\n    } else if (type === 'fail') {\r\n      this.lists.fail.push(res)\r\n    }\r\n  }\r\n\r\n  #setupParser() {\r\n    this.parser.on('line', l => this.#online(l))\r\n    this.parser.once('bailout', reason => this.onbail(reason))\r\n    this.parser.on('complete', result => this.oncomplete(result))\r\n    this.parser.on('result', res => this.#onParserResult(res))\r\n  }\r\n\r\n  /**\r\n   * Set the amount of time in milliseconds before this test is considered\r\n   * a timeout. The time is counted from right now, so for example, repeatedly\r\n   * calling `t.setTimeout(100)` can keep it going indefinitely, as long as\r\n   * you call it more often than every 100ms.\r\n   *\r\n   * Calling `setTimeout(0)` will remove the timer and allow the test to run\r\n   * indefinitely.\r\n   *\r\n   * @group Test Lifecycle Management\r\n   */\r\n  setTimeout(n: MILLISECONDS) {\r\n    if (this.timer) {\r\n      clearTimeout(this.timer)\r\n    }\r\n    if (n <= 0) {\r\n      this.timer = undefined\r\n      delete this.options.timeout\r\n    } else {\r\n      this.options.timeout = n\r\n      this.timer = setTimeout(() => this.timeout(), n)\r\n      /* c8 ignore start */\r\n      if (this.timer.unref) this.timer.unref()\r\n      /* c8 ignore stop */\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when a timeout occurs. Only exposed because it has to be called\r\n   * and/or extended by other classes, which all have their own sorts of\r\n   * timeout behavior specific to the type of thing they represent.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  timeout(\r\n    options: { expired?: string; message?: string } = {\r\n      expired: this.name,\r\n      message: 'timeout!',\r\n    },\r\n  ) {\r\n    this.timedOut = true\r\n    const { message = 'timeout!' } = options\r\n    this.setTimeout(0)\r\n    options.expired = options.expired || this.name\r\n    // timeouts don't generally have a useful callsite information,\r\n    // and no sense trying to capture it from @tapjs/stack\r\n    const extra: Extra = {\r\n      ...options,\r\n      message,\r\n      stack: '',\r\n      at: {},\r\n    }\r\n\r\n    const threw = this.threw({ message }, extra)\r\n    delete extra.stack\r\n    delete extra.at\r\n    if (threw) {\r\n      this.emit('timeout', threw)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run the `main` test function. Called by\r\n   * {@link @tapjs/core!test-base.TestBase} when starting a subtest.\r\n   * Initializes the TapWrap hook\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  runMain(cb: () => void) {\r\n    this.debug('BASE runMain')\r\n    this.start = hrtime.bigint()\r\n    this.#started = true\r\n\r\n    // if it's null or an object, inherit from it.  otherwise, copy it.\r\n    if (this.#context === unsetContext) {\r\n      const ctx =('context' in this.options ?\r\n          this.options.context\r\n        : this.parent?.context) ?? null\r\n      this.#context = typeof ctx === 'object' ? Object.create(ctx) : ctx\r\n    }\r\n\r\n    this.hook.runInAsyncScope(this.main, this, cb)\r\n  }\r\n\r\n  /**\r\n   * Returns true if this test has begun\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  get started() {\r\n    return this.#started\r\n  }\r\n\r\n  /**\r\n   * True if the test has printed *some* output of any kind\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  get printedOutput() {\r\n    return this.#printedOutput\r\n  }\r\n\r\n  /**\r\n   * Boolean indicating whether the underlying stream can be written to,\r\n   * or if it has been ended.\r\n   */\r\n  get streamWritable() {\r\n    return this.#writable\r\n  }\r\n\r\n  /**\r\n   * The main test function. For this Base class, this is a no-op. Subclasses\r\n   * implement this in their specific ways.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  main(cb: () => void) {\r\n    cb()\r\n  }\r\n\r\n  /**\r\n   * Stream write method.\r\n   *\r\n   * For buffered tests, this collects the output in the\r\n   * {@link @tapjs/core!base.Base#output}\r\n   * field. Sets {@link @tapjs/core!base.Base#printedOutput} to `true` when\r\n   * called.\r\n   *\r\n   * Note: you *probably* never need to call this. Instead, use the various\r\n   * assertion methods and other parts of the API.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  write(c: string) {\r\n    this.#printedOutput = true\r\n    if (this.buffered || this.silent) {\r\n      // need the silent output if it fails\r\n      this.output += c\r\n      return true\r\n    }\r\n\r\n    if (!this.#writable) {\r\n      return false\r\n    }\r\n\r\n    return super.write(c)\r\n  }\r\n\r\n  /**\r\n   * Method called when the parser encounters a bail out\r\n   *\r\n   * Extended by {@link @tapjs/core!test-base.TestBase}\r\n   */\r\n  onbail(reason?: string) {\r\n    this.bailedOut = reason || true\r\n    this.emit('bailout', reason)\r\n  }\r\n\r\n  /**\r\n   * Method called when parser emits a line of TAP data\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  #online(line: string) {\r\n    this.debug('LINE %j', line, [this.name, this.indent])\r\n    return this.write(this.indent + line)\r\n  }\r\n\r\n  /**\r\n   * Method called when the parser completes and emits its final results\r\n   *\r\n   * Extended by {@link @tapjs/core!worker.Worker} and\r\n   * {@link @tapjs/core!tap.TAP} classes\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  oncomplete(results: FinalResults) {\r\n    if (this.start) {\r\n      this.hrtime = hrtime.bigint() - this.start\r\n      this.time =\r\n        results.time || Math.floor(Number(this.hrtime) / 1000) / 1000\r\n    }\r\n\r\n    this.debug('ONCOMPLETE %j %j', this.name, results)\r\n\r\n    // should only ever happen once, but just in case\r\n    /* c8 ignore start */\r\n    if (this.results) {\r\n      Object.assign(results, this.results)\r\n    }\r\n    /* c8 ignore stop */\r\n\r\n    this.results = results\r\n    this.emit('complete', results)\r\n    const errors = results.failures\r\n      .filter(f => f.tapError)\r\n      .map(f => {\r\n        delete f.diag\r\n        delete f.ok\r\n        return f\r\n      })\r\n\r\n    if (errors.length) {\r\n      this.errors = errors\r\n    }\r\n\r\n    this.#writable = false\r\n    super.end()\r\n  }\r\n\r\n  /**\r\n   * extension point for plugins that want to be notified when the test\r\n   * is about to end, whether explicitly or implicitly.\r\n   *\r\n   * If the function returns a Promise, it will be awaited before ending\r\n   * the TAP stream.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  onbeforeend(): Promise<void> | void {}\r\n\r\n  /**\r\n   * extension point for plugins that want to be notified when the test\r\n   * is completely done, and terminating its parser.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  onEOF(): Promise<void> | void {}\r\n\r\n  /**\r\n   * extension point for TestBase to know when a child tests is done being\r\n   * processed and it's safe to move on to the next one.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  ondone() {}\r\n\r\n  /**\r\n   * EventEmitter emit method, but closes the\r\n   * {@link @tapjs/core!base.Base#hook} and\r\n   * {@link @tapjs/core!base.Base#hookDomain} when emitting `'end'`.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  emit<Event extends keyof Events>(\r\n    ev: Event,\r\n    ...data: Events[Event]\r\n  ) {\r\n    const ret = super.emit(ev, ...data)\r\n    if (ev === 'end') {\r\n      this.ondone()\r\n      this.hook.emitDestroy()\r\n      this.hookDomain.destroy()\r\n    }\r\n    return ret\r\n  }\r\n\r\n  /**\r\n   * Mark the test as ended. In this base class, this is a no-op, but\r\n   * in {@link @tapjs/core!test-base.TestBase}, it also triggers the other\r\n   * end-of-test operations.\r\n   */\r\n  end() {\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Method called when an unrecoverable error is encountered in a test.\r\n   *\r\n   * Typically, in tests you would not call this, you'd just actually throw\r\n   * an error.\r\n   *\r\n   * @internal\r\n   *\r\n   * @group Internal Machinery\r\n   */\r\n  threw(\r\n    er: any,\r\n    extra?: Extra,\r\n    proxy: boolean = false,\r\n    ended: boolean = false,\r\n  ): Extra | void | undefined {\r\n    this.debug('BASE.threw', er)\r\n    this.hook.emitDestroy()\r\n    this.hookDomain.destroy()\r\n    if (typeof er === 'string') {\r\n      er = { message: er }\r\n    } else if (!er || typeof er !== 'object') {\r\n      er = { error: er }\r\n    }\r\n    if (this.name && !proxy) {\r\n      er.test = this.name\r\n    }\r\n\r\n    const message = messageFromError(er)\r\n    if (!extra) {\r\n      extra = extraFromError(er, extra)\r\n    }\r\n    extra.message = message\r\n\r\n    this.parser.ok = false\r\n\r\n    // if possible to handle it here, then return the info so that this\r\n    // Base subclass can do its thing\r\n    if (\r\n      !ended &&\r\n      !this.results &&\r\n      /* c8 ignore start */\r\n      (this.parser.planEnd === -1 ||\r\n        this.parser.count < this.parser.planEnd)\r\n      /* c8 ignore stop */\r\n    ) {\r\n      return extra\r\n    }\r\n\r\n    // if we ended, we have to report it SOMEWHERE, unless we're\r\n    // already in the process of bailing out, in which case it's\r\n    // a bit excessive. Do not print it here if it would trigger\r\n    // a plan exceeded error, or if we already have results.\r\n    this.debug(\r\n      'Base.threw, but finished',\r\n      this.name,\r\n      this.results,\r\n      extra.message,\r\n    )\r\n    const alreadyBailing =\r\n      (this.results?.ok === false && this.bail) ||\r\n      this.parser.bailedOut ||\r\n      this.results?.bailout\r\n    if (this.results) this.results.ok = false\r\n    if (this.parent) {\r\n      this.parent.threw(er, extra, true)\r\n    } else if (!alreadyBailing) {\r\n      // not already bailing out, so print the error as best we can\r\n      if (!er.stack) {\r\n        console.error(er)\r\n      } else {\r\n        /* c8 ignore start */\r\n        const name = er.name || 'Error'\r\n        /* c8 ignore stop */\r\n        console.error('%s: %s', name, extra.message)\r\n        console.error(diags(extra))\r\n      }\r\n    }\r\n    // we are already bailing out, and this is the top level,\r\n    // just make our way hastily to the nearest exit.\r\n  }\r\n\r\n  /**\r\n   * returns true if the test has not as yet encountered any failures\r\n   *\r\n   * @group Test Reflection\r\n   */\r\n  passing() {\r\n    return this.parser.ok && this.results?.ok !== false\r\n  }\r\n}\r\n"]}