{"version":3,"file":"parse-test-args.js","sourceRoot":"","sources":["../../src/parse-test-args.ts"],"names":[],"mappings":"AA0BA;;GAEG;AACH,MAAM,CAAC,MAAM,aAAa,GAAG,CAI3B,GAAG,IAAoB,EACpB,EAAE;IACL,IAAI,IAAI,GAA8B,SAAS,CAAA;IAC/C,IAAI,KAAK,GAAyB,SAAS,CAAA;IAC3C,IAAI,EAAE,GAAuC,SAAS,CAAA;IAEtD,sDAAsD;IACtD,mBAAmB;IACnB,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAA;IAEjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC9C,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;QACnB,IACE,IAAI,KAAK,SAAS;YAClB,CAAC,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC,EACpD,CAAC;YACD,IAAI,GAAG,EAAE,GAAG,GAAG,CAAA;QACjB,CAAC;aAAM,IAAI,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;YAC1C,KAAK,GAAG,GAAG,CAAA;YACX,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAA;QACrC,CAAC;aAAM,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE,CAAC;YACrC,IAAI,KAAK,KAAK,SAAS;gBAAE,KAAK,GAAG,EAAO,CAAA;YACxC,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAA;YACnC,EAAE,GAAG,GAAoB,CAAA;QAC3B,CAAC;aAAM,IAAI,GAAG,KAAK,KAAK,EAAE,CAAC;YACzB,uDAAuD;YACvD,2CAA2C;YAC3C,SAAQ;QACV,CAAC;aAAM,IAAI,OAAO,GAAG,KAAK,WAAW,EAAE,CAAC;YACtC,MAAM,IAAI,SAAS,CAAC,yBAAyB,GAAG,OAAO,GAAG,CAAC,CAAA;QAC7D,CAAC;IACH,CAAC;IAED,IAAI,CAAC,KAAK;QAAE,KAAK,GAAG,EAAO,CAAA;IAE3B,MAAM,GAAG,GAAG,KAAiB,CAAA;IAC7B,IAAI,CAAC,EAAE,IAAI,WAAW,KAAK,YAAY,EAAE,CAAC;QACxC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,IAAI,IAAI,CAAA;IAC7B,CAAC;IAED,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI;QAAE,IAAI,GAAG,GAAG,CAAC,IAAI,CAAA;IAEtC,IAAI,CAAC,IAAI,IAAI,EAAE,IAAI,EAAE,CAAC,IAAI;QAAE,IAAI,GAAG,EAAE,CAAC,IAAI,CAAA;IAE1C,IAAI,GAAG,IAAI,IAAI,WAAW,CAAA;IAC1B,GAAG,CAAC,IAAI,GAAG,IAAI,CAAA;IACf,MAAM,IAAI,GAAG,KAAiB,CAAA;IAC9B,IAAI,CAAC,EAAE,GAAG,EAAE,IAAI,MAAM,CAAA;IACtB,OAAO,IAAS,CAAA;AAClB,CAAC,CAAA;AAED,MAAM,MAAM,GAAG,GAAG,EAAE;IAClB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAA;AAClD,CAAC,CAAA","sourcesContent":["import type { Base, BaseOpts, TapBaseEvents } from './base.js'\r\n\r\nimport { TestOpts } from '@tapjs/test'\r\n\r\nexport type Opts = Exclude<BaseOpts, 'parent'> & { parent?: any }\r\n\r\n/**\r\n * Argument signatures that may be passed to a subtest method.\r\n *\r\n * If a callback is not provided, then the test is marked as `todo`.\r\n */\r\nexport type TestArgs<T extends Base, O extends Opts = Opts> =\r\n  | []\r\n  | [name: string]\r\n  | [cb: ((t: T) => any) | false]\r\n  | [extra: O]\r\n  | [name: string | number, cb: ((t: T) => any) | false]\r\n  | [name: string | number, extra: O]\r\n  | [extra: O, cb: ((t: T) => any) | false]\r\n  | [\r\n      name: string | number,\r\n      extra: O,\r\n      cb: false | ((t: T) => any),\r\n      defaultName?: string,\r\n    ]\r\n\r\n/**\r\n * Normalize the arguments provided to a subtest method\r\n */\r\nexport const parseTestArgs = <\r\n  T extends Base<TapBaseEvents>,\r\n  O extends Opts = Opts,\r\n>(\r\n  ...args: TestArgs<T, O>\r\n): O => {\r\n  let name: string | null | undefined = undefined\r\n  let extra: O | null | undefined = undefined\r\n  let cb: ((t: T) => any) | null | undefined = undefined\r\n\r\n  // this only works if it's literally the 4th argument.\r\n  // used internally.\r\n  const defaultName = args[3] || ''\r\n\r\n  for (let i = 0; i < 3 && i < args.length; i++) {\r\n    const arg = args[i]\r\n    if (\r\n      name === undefined &&\r\n      (typeof arg === 'string' || typeof arg === 'number')\r\n    ) {\r\n      name = '' + arg\r\n    } else if (arg && typeof arg === 'object') {\r\n      extra = arg\r\n      if (name === undefined) name = null\r\n    } else if (typeof arg === 'function') {\r\n      if (extra === undefined) extra = {} as O\r\n      if (name === undefined) name = null\r\n      cb = arg as (t: T) => any\r\n    } else if (arg === false) {\r\n      // it's handy while developing to put a ! in front of a\r\n      // function to temporarily make a test todo\r\n      continue\r\n    } else if (typeof arg !== 'undefined') {\r\n      throw new TypeError('invalid test argument: ' + typeof arg)\r\n    }\r\n  }\r\n\r\n  if (!extra) extra = {} as O\r\n\r\n  const bex = extra as BaseOpts\r\n  if (!cb && defaultName !== '/dev/stdin') {\r\n    bex.todo = bex.todo || true\r\n  }\r\n\r\n  if (!name && bex.name) name = bex.name\r\n\r\n  if (!name && cb && cb.name) name = cb.name\r\n\r\n  name = name || defaultName\r\n  bex.name = name\r\n  const opts = extra as TestOpts\r\n  opts.cb = cb || todoCb\r\n  return opts as O\r\n}\r\n\r\nconst todoCb = () => {\r\n  throw new Error('callback called for TODO test')\r\n}\r\n"]}