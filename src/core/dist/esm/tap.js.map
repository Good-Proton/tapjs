{"version":3,"file":"tap.js","sourceRoot":"","sources":["../../src/tap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * The root TAP object singleton, the `t` you get when you\r\n * `import t from 'tap'`\r\n *\r\n * Inherits from {@link @tapjs/test!index.Test}, with all plugins applied, and\r\n * has additional functionality to automatically pipe to standard output, set\r\n * the process exit code appropriately, and infer options from environment\r\n * variables.\r\n *\r\n * @module\r\n *\r\n * @see {@link @tapjs/core!tap.TAP}\r\n */\r\nimport { Test, TestOpts } from '@tapjs/test'\r\nimport { Domain } from 'async-hook-domain'\r\nimport { Minipass, PipeOptions } from 'minipass'\r\nimport { isMainThread, parentPort } from 'node:worker_threads'\r\nimport { Handler, onExit } from 'signal-exit'\r\nimport { FinalResults } from 'tap-parser'\r\nimport { diags } from './diags.js'\r\nimport { IMPLICIT } from './implicit-end-sigil.js'\r\nimport { Extra, MILLISECONDS } from './index.js'\r\nimport { env, proc } from './proc.js'\r\nimport { TestBase } from './test-base.js'\r\n\r\nconst stdout = proc?.stdout\r\n\r\nconst privSym = Symbol.for('TAP private constructor')\r\ntype PrivateTAPCtor = {\r\n  [privSym]: true\r\n}\r\nconst privateTAPCtor: PrivateTAPCtor = {\r\n  [privSym]: true,\r\n}\r\n\r\nlet instance: TAP | undefined = undefined\r\n\r\nconst envFlag = (key: string) =>\r\n  env[key] === undefined ? undefined : env[key] === '1'\r\n\r\nlet piped = false\r\nlet registered = false\r\nlet autoend = false\r\n\r\n/**\r\n * This is a singleton subclass of the {@link @tapjs/test!index.Test} base\r\n * class.\r\n *\r\n * Instantiate it by calling the exported {@link @tapjs/core!tap.tap} method.\r\n *\r\n * It has all of the same plugins, fields, properties etc of a \"normal\"\r\n * Test object, but with some additional characteristics to make it\r\n * suitable for use as the root test runner.\r\n *\r\n * - The {@link @tapjs/core!tap.TAP#register} method will hook onto the process\r\n *   object, to set the exit code to 1 if there are test failures, and ignore\r\n *   any `EPIPE` errors that happen on stdout.  (This is quite common in cases\r\n *   where a test aborts, and then attempts to write more data.)\r\n *\r\n * - A brief summary is printed at the end of the test run.\r\n *\r\n * - If piped to stdout, then `this.register()` will be called automatically.\r\n *\r\n * - If not piped anywhere else, the first time it writes any data, it will\r\n *   begin piping to stdout.\r\n *\r\n * - Options are set based on relevant environment variables, rather than\r\n *   taking an options object, since in normal cases, it will be instantiated\r\n *   automatically before any user code is run.\r\n *\r\n * - The test will automatically implicitly end when the process exits.  If\r\n *   there are any unfinished tests at this time, they will be emitted as\r\n *   failures.\r\n *\r\n * - If a `teardown` function is added, then the test will automatically\r\n *   implicitly end if it is idle for 3 consecutive `setTimeout` deferrals.\r\n *   This is a bit of a kludge, but it allows tests to run servers or other\r\n *   things that would prevent a graceful process exit, and close them down\r\n *   in a teardown function.\r\n *\r\n * - Lastly, since test files are often spawned by the runner using\r\n *   `t.spawn()`, this class listens for the timeout signal, and attempts to\r\n *   print diagnostic information about currently active handles and requests,\r\n *   as these are usually the cause of a test hanging indefinitely.\r\n */\r\nclass TAP extends Test {\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor(priv: PrivateTAPCtor, opts: TestOpts = {}) {\r\n    /* c8 ignore start */\r\n    if (priv !== privateTAPCtor) {\r\n      throw new Error(\r\n        'the TAP singleton should not be instantiated directly',\r\n      )\r\n    }\r\n    const timeoutEnv = env.TAP_TIMEOUT || '30'\r\n    /* c8 ignore stop */\r\n\r\n    const timeout = Number(timeoutEnv) * 1000\r\n    const options = {\r\n      name: 'TAP',\r\n      diagnostic: envFlag('TAP_DIAG'),\r\n      bail: envFlag('TAP_BAIL'),\r\n      debug:\r\n        envFlag('TAP_DEBUG') ||\r\n        /\\btap\\b/i.test(env['NODE_DEBUG'] || ''),\r\n      omitVersion: envFlag('TAP_OMIT_VERSION'),\r\n      preserveWhitespace: !envFlag('TAP_OMIT_WHITESPACE'),\r\n      timeout,\r\n      failTodo: envFlag('TAP_FAIL_TODO'),\r\n      failSkip: envFlag('TAP_FAIL_SKIP'),\r\n      failOnly: envFlag('TAP_FAIL_ONLY'),\r\n      passes: envFlag('TAP_PASSES'),\r\n      // these are always set in our tests.\r\n      /* c8 ignore start */\r\n      childId: Number(env.TAP_CHILD_ID) || 0,\r\n      jobId: Number(env.TAP_JOB_ID) || 0,\r\n      /* c8 ignore stop */\r\n      ...opts,\r\n    }\r\n\r\n    // plugins get applied right here:\r\n    super(options)\r\n\r\n    instance = g[privSym] = this\r\n    this.on('idle', () => maybeAutoend())\r\n    this.on('complete', (results: FinalResults) =>\r\n      this.#oncomplete(results),\r\n    )\r\n\r\n    // only attach the teardown autoend if we're using the teardown plugin\r\n    // we test in this convoluted manner rather than this.pluginLoaded\r\n    // because otherwise we have a cyclical dep link between `@tapjs/core`\r\n    // and `@tapjs/after` which prevents TS from being able to build properly\r\n    // from a cold start.\r\n    const td = this as typeof this & {\r\n      teardown?: (fn: () => any) => void\r\n    }\r\n    const { teardown } = td\r\n    if (typeof teardown === 'function') {\r\n      type TD = typeof teardown\r\n      td.teardown = (...args: Parameters<TD>): ReturnType<TD> => {\r\n        autoend = true\r\n        td.teardown = teardown\r\n        return td.teardown(...args)\r\n      }\r\n    }\r\n\r\n    this.runMain(() => {})\r\n  }\r\n\r\n  get registered() {\r\n    return registered\r\n  }\r\n\r\n  /**\r\n   * register this tap instance as being in charge of the current process\r\n   * ignore epipe errors, set exit code, etc.\r\n   *\r\n   * Happens automatically if piped to stdout.\r\n   */\r\n  register() {\r\n    if (registered) return\r\n    registered = true\r\n    registerTimeoutListener(this)\r\n    ignoreEPIPE()\r\n    proc?.once('beforeExit', () => {\r\n      ;(this as unknown as TestBase).end(IMPLICIT)\r\n    })\r\n    proc?.once('exit', () => {\r\n      if (!this.results) {\r\n        this.endAll()\r\n      }\r\n    })\r\n    // create a root domain to handle throws that happen outside\r\n    // of any subtest.\r\n    const rootDomain = new Domain((er, type) =>\r\n      this.hookDomain.onerror(er, type),\r\n    )\r\n    this.hook.onDestroy = () => rootDomain.destroy()\r\n  }\r\n\r\n  onbail(reason?: string) {\r\n    if (registered) {\r\n      this.debug('bailout, exit 1')\r\n      super.write(`Bail out!${reason ? ' ' + reason : ''}\\n`)\r\n    }\r\n    super.onbail(reason)\r\n    // don't fast-exit in the runner, so we can print the reason for\r\n    // the bailout on test failure.\r\n    if (registered && this.context !== Symbol.for('tap.isRunner')) {\r\n      proc?.exit(1)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Just the normal Minipass.pipe method, but automatically registers\r\n   * if the destination is stdout.\r\n   */\r\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\r\n    piped = true\r\n    if (stdout && dest === stdout) {\r\n      this.register()\r\n    }\r\n    return super.pipe(dest, opts)\r\n  }\r\n\r\n  /**\r\n   * Just the normal Minipass.write method, but automatically pipes\r\n   * to stdout if not piped anywhere else.\r\n   */\r\n  write(chunk: string): boolean {\r\n    if (!registered && !piped && stdout) {\r\n      this.pipe(stdout)\r\n    }\r\n    return super.write(chunk)\r\n  }\r\n\r\n  #oncomplete(results: FinalResults) {\r\n    // only print this added info in the root test, otherwise\r\n    // it's a bit extraneous.\r\n    if (!env.TAP_CHILD_ID) {\r\n      this.comment(this.counts.toJSON())\r\n      this.comment(`time=${this.time}ms`)\r\n    }\r\n\r\n    if (registered && proc && !results.ok) {\r\n      this.debug('TAP results not ok, setting exitCode', results)\r\n      proc.exitCode = 1\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Similar to the normal {@link @tapjs/core!test-base.TestBase#timeout}, but\r\n   * with the added feature that it will kill the process with `SIGALRM` if it\r\n   * has been registered, and will decorate the diagnostics with some\r\n   * information about currently running handles and requests, as these may be\r\n   * the reason the process is not gracefully closing in time.\r\n   *\r\n   * The root test runner will time out if the process receives a `SIGALRM`\r\n   * signal, or if it receives a timeout message via IPC or worker thread\r\n   * channel.\r\n   */\r\n  timeout(\r\n    options: {\r\n      expired?: string\r\n      signal?: NodeJS.Signals | null\r\n    } = { expired: this.name, signal: null },\r\n  ) {\r\n    const occ = this.occupied\r\n    const extra = Object.assign(\r\n      getTimeoutExtra(options.signal),\r\n      options,\r\n    )\r\n    super.timeout(extra)\r\n    if (occ) this.emit('timeout', extra)\r\n    // don't stick around\r\n    // this is just a defense if the SIGALRM signal is caught, since\r\n    // we'll exit forcibly anyway.\r\n    /* c8 ignore start */\r\n    if (registered) {\r\n      setTimeout(() => {\r\n        didProcessTimeout = true\r\n        alarmKill()\r\n      }, 10000)?.unref?.()\r\n    }\r\n    /* c8 ignore stop */\r\n  }\r\n\r\n  // tell our parent process about our intended timeout\r\n  setTimeout(n: MILLISECONDS) {\r\n    const msg = {\r\n      setTimeout: n,\r\n      key: env.TAP_CHILD_KEY,\r\n      child: env.TAP_CHILD_ID,\r\n    }\r\n    proc?.send?.(msg)\r\n    // workers can't generate coverage\r\n    /* c8 ignore start */\r\n    parentPort?.postMessage(msg)\r\n    /* c8 ignore stop */\r\n    return super.setTimeout(n)\r\n  }\r\n}\r\n\r\nconst shouldAutoend = (instance: TAP | undefined): instance is TAP =>\r\n  !!autoend && !!instance?.idle\r\n\r\nlet autoendTimer: NodeJS.Timeout | undefined = undefined\r\nconst maybeAutoend = () => {\r\n  clearTimeout(autoendTimer)\r\n  if (!shouldAutoend(instance)) return\r\n  autoendTimer = setTimeout(() => {\r\n    clearTimeout(autoendTimer)\r\n    if (shouldAutoend(instance)) {\r\n      autoendTimer = setTimeout(() => {\r\n        clearTimeout(autoendTimer)\r\n        if (shouldAutoend(instance)) {\r\n          ;(instance as unknown as TestBase).end(IMPLICIT)\r\n          autoend = false\r\n        }\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\n// SIGALRM means being forcibly killed due to timeout\r\nconst registerTimeoutListener = (t: TAP) => {\r\n  const oe: Handler = (_, sig) => {\r\n    if (sig === 'SIGALRM' && !didProcessTimeout) {\r\n      onProcessTimeout(t, sig)\r\n      onExit(oe)\r\n      return true\r\n    }\r\n  }\r\n  onExit(oe)\r\n  const onMessage = (\r\n    msg:\r\n      | {\r\n          tapAbort?: string\r\n          key?: string\r\n          child?: string\r\n        }\r\n      | any,\r\n  ) => {\r\n    if (\r\n      msg &&\r\n      typeof msg === 'object' &&\r\n      msg.tapAbort === 'timeout' &&\r\n      msg.key === env.TAP_CHILD_KEY &&\r\n      msg.child === env.TAP_CHILD_ID\r\n    ) {\r\n      onProcessTimeout(t, 'SIGALRM')\r\n    }\r\n  }\r\n\r\n  // this is a bit of a handshake agreement between the root TAP object\r\n  // and the Spawn and Worker classes. Because Windows cannot catch and\r\n  // process posix signals, we have to use an IPC message to send the\r\n  // timeout signal.\r\n  // t.spawn() will always open an ipc channel on fd 3 for this purpose,\r\n  // and t.worker() will use the worker message port.\r\n  // The key and childId are just a basic gut check to ensure that we don't\r\n  // treat a message as a timeout unintentionally, though of course that\r\n  // would be extremely rare.\r\n\r\n  /* c8 ignore start */\r\n  proc?.on('message', onMessage)\r\n  parentPort?.on('message', onMessage)\r\n\r\n  // We don't want the channel to keep the child running\r\n  //@ts-ignore\r\n  proc?.channel?.unref()\r\n  parentPort?.unref()\r\n  /* c8 ignore stop */\r\n}\r\n\r\nconst getTimeoutExtra = (signal: NodeJS.Signals | null = null) => {\r\n  const p = process as unknown as {\r\n    _getActiveHandles: () => any[]\r\n    _getActiveRequests: () => any[]\r\n  }\r\n\r\n  /* c8 ignore start */\r\n  const handles = (p._getActiveHandles() || []).filter(\r\n    /* c8 ignore stop */\r\n    h =>\r\n      h !== proc?.stdout && h !== proc?.stdin && h !== proc?.stderr,\r\n  )\r\n  const requests = p._getActiveRequests()\r\n\r\n  const extra: Extra = {\r\n    at: undefined,\r\n    signal,\r\n  }\r\n\r\n  // node 20 doesn't have requests in the same way as node 18\r\n  // we get different objects, handles vs requests, etc.\r\n  // it's all very \"internal machinery\", version specific and unstable\r\n  // there are tests to show that we can get SOMETHING in expected cases,\r\n  // but it'll be completely differerent across node versions.\r\n  /* c8 ignore start */\r\n  if (requests.length) {\r\n    extra.requests = requests.map(r => {\r\n      if (!r || typeof r !== 'object') return r\r\n      const ret: {\r\n        type: string\r\n        context?: any\r\n      } = {\r\n        type: r.constructor.name,\r\n      }\r\n      if (r.context) ret.context = r.context\r\n      return ret\r\n    })\r\n  }\r\n\r\n  if (handles.length) {\r\n    extra.handles = handles.map(h => {\r\n      if (!h || typeof h !== 'object') return h\r\n      const ret: {\r\n        type: string\r\n        msecs?: number\r\n        events?: string[]\r\n        sockname?: string\r\n        connectionKey?: string\r\n      } = {\r\n        type: h.constructor.name,\r\n      }\r\n      if (h.msecs) ret.msecs = h.msecs\r\n      if (h._events) ret.events = Object.keys(h._events)\r\n      if (h._sockname) ret.sockname = h._sockname\r\n      if (h._connectionKey) ret.connectionKey = h._connectionKey\r\n      return ret\r\n    })\r\n  }\r\n  /* c8 ignore stop */\r\n\r\n  return extra\r\n}\r\n\r\nlet didProcessTimeout = false\r\nconst onProcessTimeout = (\r\n  t: TAP,\r\n  signal: NodeJS.Signals | null = null,\r\n) => {\r\n  // pretty much impossible to do this, since we forcibly exit,\r\n  // but it is theoretically possible if SIGALRM is caught.\r\n  /* c8 ignore start */\r\n  if (didProcessTimeout) return\r\n  /* c8 ignore stop */\r\n  didProcessTimeout = true\r\n\r\n  const extra = getTimeoutExtra(signal)\r\n\r\n  // ignore coverage here because it happens after everything\r\n  // must have been shut down.\r\n  /* c8 ignore start */\r\n  if (!t.results) {\r\n    t.timeout(extra)\r\n  } else {\r\n    if (extra.handles || extra.requests) {\r\n      delete extra.signal\r\n      if (!extra.at) {\r\n        delete extra.at\r\n      }\r\n    }\r\n    console.error(diags(extra))\r\n  }\r\n  // defer to print the timeout failure before termination\r\n  setTimeout(() => alarmKill())\r\n}\r\n\r\nconst alarmKill = () => {\r\n  // can only kill in main thread, worker threads will be terminated\r\n  if (!isMainThread) return\r\n\r\n  // SIGALRM isn't supported everywhere,\r\n  // and we won't be able to catch it on windows anyway.\r\n  /* c8 ignore start */\r\n  try {\r\n    proc?.kill(proc?.pid, 'SIGALRM')\r\n  } catch {\r\n    proc?.kill(proc?.pid, 'SIGKILL')\r\n  }\r\n  const t = setTimeout(() => {\r\n    proc?.kill(proc?.pid, 'SIGKILL')\r\n  }, 500)\r\n  if (t.unref) t.unref()\r\n}\r\n/* c8 ignore stop */\r\n\r\nconst ignoreEPIPE = () => {\r\n  /* c8 ignore start */\r\n  if (!stdout?.emit) return\r\n  /* c8 ignore stop */\r\n  const emit = stdout.emit\r\n  stdout.emit = (ev: string, ...args: any[]) => {\r\n    const er = args[0] as NodeJS.ErrnoException\r\n    if (ev === 'error' && er?.code === 'EPIPE') {\r\n      return false\r\n    }\r\n    //@ts-ignore\r\n    return emit.call(stdout, ev, ...args)\r\n  }\r\n}\r\n\r\nconst g = globalThis as typeof globalThis & {\r\n  [privSym]: TAP\r\n}\r\n\r\n/**\r\n * The exported function instantiates a {@link @tapjs/core!tap.TAP} object if\r\n * we don't already have one, or return the one that was previously\r\n * instantiated.\r\n *\r\n * Options may be provided, which will override the environment settings,\r\n * but they are ignored if the instance was already created.\r\n */\r\nexport const tap = (opts?: TestOpts) =>\r\n  instance ?? g[privSym] ?? new TAP(privateTAPCtor, opts)\r\n\r\nexport type { TAP }\r\n"]}